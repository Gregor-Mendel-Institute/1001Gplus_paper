---
title: "Graph of TEs"
# output: html_notebook
output: null_document
---


# Setup
## My Libs
```{r}

path.base = '../../../'

path.pannagram = paste(path.base, '../pannagram/', sep = '')

source(paste(path.pannagram, 'sim/sim_func.R', sep = ''))
source(paste(path.pannagram, 'analys/graph_func.R', sep = ''))
source(paste(path.pannagram, 'utils/utils.R', sep = ''))
source(paste(path.pannagram, 'visualisation/dotplot.R', sep = ''))
source(paste(path.pannagram, 'visualisation/msaplot.R', sep = ''))
source(paste(path.pannagram, 'visualisation/orfplot.R', sep = ''))

source(paste(path.pannagram, 'visualisation/visualisation.R', sep = ''))
```


## Libs
```{r, message=FALSE}
packages <- c("ggpattern", 
              "viridis", 
              "colorRamps", 
              "gridExtra", 
              "ggplot2", 
              "igraph", 
              "network", 
              "khroma", 
              "dplyr", 
              "ggpubr", 
              "Biostrings")

invisible(sapply(packages, load.library))


if (!require("ggnet", character.only = TRUE, quietly = TRUE)) {
    load.library("devtools")
    devtools::install_github("briatte/ggnet")
}
library(ggnet)

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager", quiet = TRUE)
# BiocManager::install("Biostrings")



# source('similarity.R')
# source('graph_refinement.R')
# source('dotplot.R')
# source('msaplot.R')

sunset <- colour("sunset")
discrete_rainbow <- colour("discrete rainbow")

path.analysis = paste(path.base, '02_analysis/04_sv/', sep = '')
path.work = paste(path.analysis, '01_data/', sep = '')
path.figures = paste(path.analysis, '03_figures/', sep = '')

path.svs = paste(path.base, '01_data/04_annotation/02_pannagram/svs/', sep = '')
path.tair = paste(path.base, '01_data/09_tair10/', sep = '')


# sim.cutoff = 0.9

sim.cutoff = 0.85

```

## Colors
```{r}

# ---- Colors of TE content ----
te.content.names = c("noTE", "isTE", "hasTE", "hasTEpart", "isTEpart")
te.cols = c('#D8D9CF', '#EB455F', '#7B6079', '#3C8DAD', '#79B773')
names(te.cols) = te.content.names
te.cols['Mix'] = 'grey20'


# ---- Colors of BLAST hits ----
colors.blast.hits <- c("in graph" = "#676FA3",
            "partial overlap" = "#FF9F29",
            "1 self-hit" = "#6EBF8B",
            "0 hits" = "#D82148",
            "in graph but not in SVs" = "#151D3B")


# ---- Colors of known TE families ----
fam.palette = c()
fam.palette['Unassigned'] = 'grey'
fam.palette['Mix'] = 'grey20'
fam.palette['Mix with Helitron'] = '#266D98'
fam.palette['Helitron'] = '#BCACDE'
fam.palette['RC/Helitron'] = '#BCACDE'
fam.palette["LTR/Copia"] = '#BFDB38'
fam.palette["LTR/Gypsy"] = '#54B435'
fam.palette["DNA/HAT"] = '#F9B5D0'
fam.palette["DNA+"] = '#C8658C'
fam.palette["DNA"] = '#C8658C'
fam.palette["DNA/Pogo"] = '#C8658C'
fam.palette["DNA/MuDR"] = '#971549'


fam.palette["LINE"] = '#FFC26F'
fam.palette["LINE/L1"] = '#FFC26F'
fam.palette["RathE1/2/3_cons"] = '#C38154'
fam.palette["SINE"] = '#884A39'
fam.palette["TEG"] = '#4E3636'


# Colors for new TEs
# g.cols = discrete_rainbow(length(unique(sv.memb$prot)))
# names(g.cols) = unique(sv.memb$prot)
# names(g.cols) = c('no prot', "undefined prot", "reverse", "transpos","repeat","zinc", "receptor","defined prot")
g.cols = c()
g.cols['disease'] = 'black'
g.cols['zinc'] = '#F45050'
g.cols['repeat'] = '#EA906C'
g.cols['receptor'] = '#F7D060'
g.cols['reverse'] = '#98D8AA'
g.cols['transpos'] = '#4EB265'
g.cols['defined prot'] = '#7BAFDE'
g.cols['undefined prot'] = '#1965B0'
g.cols['no prot'] = '#882E72'


# Colors for indels

# indel.pallete = c("I"='black', "M"='grey40', "D"='grey70')
indel.pallete = c("I"='black', "M"='#595260', "D"='#B2B1B9')
indel.new.names = c("I" = "Insertion", "M"='Variation', "D"='Deletion')
names(indel.pallete) = indel.new.names[names(indel.pallete)]

```



# TEs
```{r}

# Load similarity function

bl.file = paste(path.work,'new_te_on_te.fasta',sep = '')
bl.res = read.table(bl.file)
bl.res = bl.res[bl.res$V1 != bl.res$V8,]

bl.res.init = bl.res
bl.res = bl.res[bl.res$V6 >= sim.cutoff * 100,]

res.nest = findNestedness(bl.res, use.strand = F)

res.nest.len = sapply(unique(c(res.nest$V1, res.nest$V8)), function(s) as.numeric(strsplit(s, '\\|')[[1]][5]))
  
res.nest$len1 = res.nest.len[res.nest$V1]
res.nest$len8 = res.nest.len[res.nest$V8]
res.nest$p1 = res.nest$C1 / res.nest$len1
res.nest$p8 = res.nest$C8 / res.nest$len8

res.nest.sim = res.nest[(res.nest$p1 >= sim.cutoff) | 
                          (res.nest$p8 >= sim.cutoff),]
```

## How many TEs are in the graph
Distribution among families and subfamilies
Distribution among lengths
```{r}
te.in.graph = unique(c(res.nest$V1, res.nest$V8))

# What is the actual number of TEs
file.content <- readLines(bl.file)

selected.lines <- file.content[grepl("^# Query:|hits found", file.content)]
df.query = data.frame(b.query=selected.lines[seq(1, length(selected.lines), by = 2)],
                      b.hits=selected.lines[seq(2, length(selected.lines), by = 2)])

df.query$query  <- gsub("^# Query: (.*)", "\\1", df.query$b.query)
df.query$len <- as.numeric(sapply(strsplit(df.query$query, "\\|"), function(x) x[5]))
df.query$hits <- as.numeric(stringr::str_extract(df.query$b.hits, "\\d+"))
df.query$val.hits = df.query$hits
df.query$val.hits[df.query$val.hits >= 2] = 2
df.query$val.hits[df.query$query %in% bl.res$V8] = 2
df.query$val.hits[df.query$query %in% te.in.graph] = 3
hit.values = c('0 hits', '1 self-hit', 'partial overlap', 'in graph', "in graph but not in SVs")
df.query$s.hits = hit.values[df.query$val.hits+1]
df.query$s.hits = factor(df.query$s.hits, levels = rev(hit.values))
df.query$family <- sapply(strsplit(df.query$query, "\\|"), function(x) x[9])
df.query$subfam <- sapply(strsplit(df.query$query, "\\|"), function(x) x[8])



# TEs, which are not in SVs
te.in.svs = read.table(paste(path.work, 'blast_tes_on_sv.txt', sep = ''), stringsAsFactors = F)
te.rest = setdiff(df.query$query, te.in.svs$V1)
te.in.svs = read.table(paste(path.work, 'blast_sv_on_tes.txt', sep = ''), stringsAsFactors = F)
te.rest = setdiff(te.rest, te.in.svs$V8)
df.query$s.hits[df.query$query %in% te.rest] = "in graph but not in SVs"


p = ggplot(df.query, aes(x = len, fill = s.hits, color = s.hits)) +
  # geom_histogram(aes(y = ..density..), alpha=0.5, color = "black", bins = 30) +
  # geom_jitter(height = 0.02, width = 0, alpha = 0.7) +
  geom_density(alpha = 0.5) +
  scale_fill_manual(values = colors.blast.hits) +
  scale_color_manual(values = colors.blast.hits) +
   scale_x_log10() +
  labs(fill = NULL, color = NULL) +
  xlab('length of TEs') + ylab('Normalised density') +
  theme_minimal() +
  theme(legend.position = c(1, 1), legend.justification = c(1, 1),
          legend.background = element_rect(color = "grey90"))

p

# pdf(paste(path.figures, 'tes_self_blast_len_density.pdf', sep = ''), width = 5, height = 4)
# print(p)     # Plot 1 --> in the first page of PDF
# dev.off()


table(df.query$val.hits)
```


### TEs not in SVs
```{r}
# TEs in te-graph: te.in.graph
# TEs which are have no connection to SVs

df = as.data.frame(table(df.query$s.hits))

p = ggplot(df, aes(x = "", y = Freq, fill = Var1)) +
  geom_bar(stat="identity", width=1, alpha = 0.7) +
  coord_polar("y", start=0) +
  labs(title=NULL, fill="Categories") +
  theme_void()+
    scale_fill_manual(values = colors.blast.hits) +
  geom_text(aes(label = Freq ,x = 1.3), position = position_stack(vjust = 0.5)) + theme(legend.position="none")
p

pdf(paste(path.figures, 'tes_self_blast_pie_chart.pdf', sep = ''), width = 3, height = 3)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

```

## Examples
### Examples no hits
```{r}


df.query.tmp = df.query[(df.query$val.hits == '0'),]

cnt.init = c(table(df.query$family))
cnt.tmp = c(table(df.query.tmp$family))

common_names <- intersect(names(cnt.init), names(cnt.tmp))
# Создание dataframe только для совпадающих имен
df_match <- data.frame(names = common_names, values.init = cnt.init[common_names], 
                       values.tmp = cnt.tmp[common_names])


gradient_colors <- c(discrete_rainbow(nrow(df_match)))
names(gradient_colors) = NULL


p = ggplot(df_match, aes(x = values.init, y = values.tmp, label = names, color = names)) +
  geom_point() +
  # geom_text(hjust = 0, vjust = 0) +
  ggrepel::geom_text_repel(max.overlaps = 20) +
  xlab("Initial counts") +
  ylab("counts of No hits") +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = gradient_colors) +
  theme(legend.position = "none") +
  guides(color = FALSE) +
  theme_minimal()
p


pdf(paste(path.figures, 'tes_self_scatter_no_hits.pdf', sep = ''), width = 5, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

# No hits and long
len.min = 100
df.query.tmp = df.query[(df.query$val.hits == '0') & (df.query$len >= len.min),]


cnt.init = c(table(df.query$family))
cnt.tmp = c(table(df.query.tmp$family))

common_names <- intersect(names(cnt.init), names(cnt.tmp))
# Создание dataframe только для совпадающих имен
df_match <- data.frame(names = common_names, values.init = cnt.init[common_names], 
                       values.tmp = cnt.tmp[common_names])


gradient_colors <- c(discrete_rainbow(nrow(df_match)))
names(gradient_colors) = NULL

p = ggplot(df_match, aes(x = values.init, y = values.tmp, label = names, color = names)) +
  geom_point() +
  # geom_text(hjust = 0, vjust = 0) +
  # ggrepel::geom_text_repel(max.overlaps = 20) +
  ggrepel::geom_text_repel(aes(label = paste(names,'(',values.tmp,')',sep ='')), max.overlaps = 20) +
  xlab("Initial counts") +
  ylab("counts of No hits") +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = gradient_colors) +
  theme(legend.position = "none") +
  guides(color = FALSE) +
  theme_minimal() +
  geom_text(aes(x=0,y=Inf,hjust=0, vjust=3,
                label=paste('Length >=', len.min)), color = 'grey20')
p


pdf(paste(path.figures, 'tes_self_scatter_no_hits_long.pdf', sep = ''), width = 5, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()


```

```{r}

head(df.query.tmp[df.query.tmp$family == 'DNA/MuDR',]$query)
```


### Examples one self-hit
#### families
```{r}


df.query.tmp = df.query[(df.query$val.hits == 1),]

cnt.init = c(table(df.query$family))
cnt.tmp = c(table(df.query.tmp$family))

common_names <- intersect(names(cnt.init), names(cnt.tmp))
# Создание dataframe только для совпадающих имен
df_match <- data.frame(names = common_names, values.init = cnt.init[common_names], 
                       values.tmp = cnt.tmp[common_names])


gradient_colors <- c(discrete_rainbow(nrow(df_match)))
names(gradient_colors) = NULL


p = ggplot(df_match, aes(x = values.init, y = values.tmp, label = names, color = names)) +
  geom_point() +
  # geom_text(hjust = 0, vjust = 0) +
  ggrepel::geom_text_repel(max.overlaps = 20) +
  xlab("Initial counts") +
  ylab("Counts in \"1 self-hits\" category") +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = gradient_colors) +
  theme(legend.position = "none") +
  guides(color = FALSE) +
  theme_minimal()
p


pdf(paste(path.figures, 'tes_self_scatter_1_selfhits_fam.pdf', sep = ''), width = 5, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()
```

#### subfamilies
```{r}


df.query.tmp = df.query[(df.query$val.hits == 1) & (df.query$len >= 600),]

cnt.init = c(table(df.query$subfam))
cnt.tmp = c(table(df.query.tmp$subfam))

common_names <- intersect(names(cnt.init), names(cnt.tmp))
# Создание dataframe только для совпадающих имен
df_match <- data.frame(names = common_names, values.init = cnt.init[common_names], 
                       values.tmp = cnt.tmp[common_names])


# gradient_colors <- c(discrete_rainbow(nrow(df_match)))
names(gradient_colors) = NULL


p = ggplot(df_match, aes(x = values.init, y = values.tmp, label = names, color = names)) +
  geom_point() +
  # geom_text(hjust = 0, vjust = 0) +
  ggrepel::geom_text_repel(max.overlaps = 20) +
  xlab("Initial counts") +
  ylab("Counts in \"1 self-hits\" category") +
  scale_x_log10() +
  scale_y_log10() +
  # scale_color_manual(values = gradient_colors) +
  theme(legend.position = "none") +
  guides(color = FALSE) +
  theme_minimal()
p


pdf(paste(path.figures, 'tes_self_scatter_1_selfhits_subfam.pdf', sep = ''), width = 7, height = 5)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()


```

#### individuals from subfamilies
```{r}
s.subfam = 'ATREP8'

df.query.tmp = df.query[(df.query$subfam == s.subfam) & (df.query$len >= 600),]
df.query.tmp


```





## Creating the graph
```{r}
# all edges
idx = res.nest$p1 >= sim.cutoff
edges = cbind(res.nest$V1[idx], res.nest$V8[idx])
idx = res.nest$p8 >= sim.cutoff
edges = rbind(edges, cbind(res.nest$V8[idx], res.nest$V1[idx]))
te.enges.names = unique(c(edges[,1], edges[,2]))
te.enges.fam = sapply(te.enges.names, function(s) strsplit(s, '\\|')[[1]][9] )

te.enges.fam[te.enges.fam %in% c('DNA/Pogo', 'DNA/Tc1', 'DNA/Harbinger', 'DNA/En-Spm',
                     'DNA/HAT', 'DNA', 'DNA/Mariner')] = 'DNA'
te.enges.fam[te.enges.fam %in% c('RathE1_cons', 'RathE2_cons', 'RathE3_cons')] = 'RathE1/2/3_cons'
te.enges.fam[te.enges.fam %in% c('LINE/L1', 'LINE?')] = 'LINE'
te.enges.fam[te.enges.fam %in% c('Unassigned')] = 'Mix'
te.enges.fam[te.enges.fam %in% c('RC/Helitron')] = 'Helitron'

edges = edges[te.enges.fam[edges[,1]] != 'TEG',]
edges = edges[te.enges.fam[edges[,2]] != 'TEG',]
te.enges.names = unique(c(edges[,1], edges[,2]))


# nodes
idx = (res.nest$p1 >= sim.cutoff) & (res.nest$p8 >= sim.cutoff)
te.nodes = cbind(res.nest$V1[idx], res.nest$V8[idx])
te.nodes = te.nodes[te.enges.fam[te.nodes[,1]] != 'TEG',]
te.nodes = te.nodes[te.enges.fam[te.nodes[,2]] != 'TEG',]

te.rest = setdiff(te.enges.names, c(te.nodes[,1], te.nodes[,2]))


te.nodes.graph <- igraph::make_graph(t(te.nodes), directed = T)
te.nodes.graph <- igraph::simplify(te.nodes.graph)
te.nodes.comp <- igraph::components(te.nodes.graph)

nodes = data.frame(node = paste('N', te.nodes.comp$membership, sep = ''), 
                   te = names(te.nodes.comp$membership))

nodes.rest = data.frame(node = paste('R', (1:length(te.rest)), sep = ''), te = te.rest)
nodes = rbind(nodes, nodes.rest)

rownames(nodes) = nodes$te


nodes.cnt = data.frame(cnt = c(table(nodes$node)))
nodes.cnt$node = rownames(nodes.cnt)
nodes.cnt$fam = sapply(nodes.cnt$node, function(s){
  s.te = nodes$te[nodes$node == s]
  fam.te = unique(te.enges.fam[s.te])
  if(length(fam.te) == 1){
    return(fam.te)
  } else {
    fam.te = setdiff(fam.te, 'TEG')
    if(length(fam.te) == 1) return(fam.te)
    return('Mix')
  }
})
table(nodes.cnt$fam)


# Redefine edges but with node names
idx.endes = (edges[,1] %in% nodes$te) & (edges[,2] %in% nodes$te)
b.graph = cbind(nodes[edges[idx.endes,1], 'node'],nodes[edges[idx.endes,2], 'node'])
b.graph = unique(b.graph)
# b.graph = b.graph[b.graph[,1] != b.graph[,2],]
b.graph.uni = b.graph[b.graph[,1] == b.graph[,2],]
b.graph = b.graph[b.graph[,1] != b.graph[,2],]

length(unique(c(b.graph[,1], b.graph[,2])))

# reduce indirect arrows
idx.remove = c()
for(i.edge in 1:nrow(b.graph)){
  if(i.edge %% 1000 == 0) print(i.edge)
  tmp.to = b.graph[b.graph[,1] == b.graph[i.edge,1],2]
  tmp.from = b.graph[b.graph[,2] == b.graph[i.edge,2],1]
  if(length(intersect(tmp.to, tmp.from)) > 0) idx.remove = c(idx.remove, i.edge)
}
idx.remove = unique(idx.remove)
b.graph = b.graph[-idx.remove,]
# b.graph = rbind(b.graph, b.graph.uni)

# Print graph

g.nodes.fam = nodes.cnt$fam
names(g.nodes.fam) = nodes.cnt$node
g.nodes.cnt = nodes.cnt$cnt
names(g.nodes.cnt) = nodes.cnt$node

g.cols = discrete_rainbow(length(unique(g.nodes.fam)))
names(g.cols) = unique(g.nodes.fam)

b.graph.init = b.graph


g.part <- network(b.graph, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
b.graph.names = network.vertex.names(g.part)
```

### Old colors
```{r}
# p <- ggnet2(g.part, label = F, edge.color = "black", 
#             node.size = g.nodes.cnt[b.graph.names], 
#             color = g.nodes.fam[b.graph.names],
#             palette = g.cols,
#             # mode = "kamadakawai"
#             ) 
# p + guides(size = F)
# 
# # 
# # b.graph.fam = cbind(g.nodes.fam[b.graph[,1]], g.nodes.fam[b.graph[,2]])
# # b.graph.fam
# # 
# # which((b.graph.fam[,1] == 'DNA/MuDR') & (b.graph.fam[,1] == 'LINE'))
# 


```

### New Family colors
```{r}
# g.fam.names = sort(unique(g.nodes.fam))
# fam.palette = c()
# idx.pallete = c()
# 
# idx.fam <- grep("^Helitron", g.fam.names, value = FALSE)
# tmp.palette <- colorRampPalette(c('#BFACE2', '#266D98', '#422B72'))(length(idx.fam))
# idx.pallete = c(idx.pallete, idx.fam)
# fam.palette = c(fam.palette, tmp.palette)
# 
# idx.fam <- grep("^LTR", g.fam.names, value = FALSE)
# tmp.palette <- colorRampPalette(c('#BFDB38', '#54B435'))(length(idx.fam))
# idx.pallete = c(idx.pallete, idx.fam)
# fam.palette = c(fam.palette, tmp.palette)
# 
# idx.fam <- grep("^DNA", g.fam.names, value = FALSE)
# tmp.palette <- colorRampPalette(c('#F9B5D0', '#971549'))(length(idx.fam))
# idx.pallete = c(idx.pallete, idx.fam)
# fam.palette = c(fam.palette, tmp.palette)
# 
# idx.fam = setdiff(1:length(g.fam.names), idx.pallete)
# tmp.palette <- colorRampPalette(c('#FFC26F', '#C38154', '#884A39', '#4E3636'))(length(idx.fam))
# idx.pallete = c(idx.pallete, idx.fam)
# fam.palette = c(fam.palette, tmp.palette)
# 
# names(fam.palette) = g.fam.names[idx.pallete]
# fam.palette['Unassigned'] = 'grey'
# fam.palette['Mix'] = 'black'
# fam.palette['TEG'] = 'darkgreen'




```

```{r}

set.seed(20)

g.part %v% "colors" = g.nodes.fam[b.graph.names]
g.part %v% "node.size" = g.nodes.cnt[b.graph.names]

p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = "node.size",
            color = "colors",
            palette = fam.palette,
            # mode = "kamadakawai"
            ) 
p = p + guides(size = F) 
p = p + coord_fixed(ratio = 1)
p



pdf(paste(path.figures, 'graph_tes_family.pdf', sep = ''), width = 5, height = 5)
print(p+ theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()

pdf(paste(path.figures, 'graph_tes_family_legend.pdf', sep = ''), width = 7, height = 5)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

```



## Separately visualise connected components
```{r}
tmp.graph <- igraph::make_graph(t(b.graph), directed = T)
tmp.graph <- igraph::simplify(tmp.graph)
tmp.comp <- igraph::components(tmp.graph)

tmp.cnt = table(tmp.comp$membership)
tmp.cnt = -sort(-tmp.cnt)
head(tmp.cnt)

k = 1
tmp.k = as.numeric(names(tmp.cnt)[k])
tmp.names = names(tmp.comp$membership)[tmp.comp$membership == tmp.k]
b.graph.sub = b.graph[(b.graph[,1] %in% tmp.names) & 
                        (b.graph[,2] %in% tmp.names),]

g.part.sub.big <- network(b.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
b.graph.names.sub.big = network.vertex.names(g.part.sub.big)


set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = g.nodes.cnt[b.graph.names.sub.big], 
            color = g.nodes.fam[b.graph.names.sub.big],
            mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F)
p.big.type = p + theme(legend.position = "none")

# set.seed(20)
# p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
#             node.size = g.nodes.cnt[b.graph.names.sub.big], 
#             color = g.nodes.fam[b.graph.names.sub.big],
#             mode = 'kamadakawai',
#             palette = fam.palette) + guides(size = F)
# p.big.color = p + theme(legend.position = "none")


tmp.k = as.numeric(names(tmp.cnt)[k])
tmp.names = names(tmp.comp$membership)[tmp.comp$membership != tmp.k]
b.graph.sub = b.graph[(b.graph[,1] %in% tmp.names) & 
                        (b.graph[,2] %in% tmp.names),]

g.part.sub.small <- network(b.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
b.graph.names.sub.small = network.vertex.names(g.part.sub.small)


set.seed(20)
p <- ggnet2(g.part.sub.small, label = F, edge.color = "black", 
            node.size = g.nodes.cnt[b.graph.names.sub.small], 
            color = g.nodes.fam[b.graph.names.sub.small],
            # mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F)
p.small.type =p + theme(legend.position = "none")

# set.seed(20)
# p <- ggnet2(g.part.sub.small, label = F, edge.color = "black", 
#             node.size = g.nodes.cnt[b.graph.names.sub.small], 
#             color = g.nodes.fam[b.graph.names.sub.small],
#             # mode = 'kamadakawai',
#             palette = fam.palette) + guides(size = F)
# p.small.color = p + theme(legend.position = "none")



```

### Plots
```{r}
p.big.type
p.small.type


pdf(paste(path.figures, 'graph_tes_family_small.pdf', sep = ''), width = 9, height = 9)
print(p.small.type)     # Plot 1 --> in the first page of PDF
dev.off()

pdf(paste(path.figures, 'graph_tes_family_big.pdf', sep = ''), width = 5, height = 5)
print(p.big.type)     # Plot 1 --> in the first page of PDF
dev.off()

```

# Stop for the paper
```{r}
stop()
```


## Specific TE families
### Graph of one family

```{r}
sort(-table(df.query$subfam[(df.query$val.hits == 3) & (df.query$family == 'LTR/Copia')]))
```



```{r}

# one.te.fam = 'BRODYAGA1'
# one.te.fam = 'BRODYAGA2'
# one.te.fam = 'HELITRONY1D'
# one.te.fam = 'HELITRONY3'
one.te.fam = 'ATCOPIA41'
query.fam = df.query$query[df.query$subfam == one.te.fam]


one.te.fam = 'ATCOPIA41'
query.fam = df.query$query[df.query$subfam == one.te.fam]

res.nest.famp = res.nest[(res.nest$V1 %in% query.fam) | (res.nest$V8 %in% query.fam),]


idx = res.nest.famp$p1 >= sim.cutoff
edges = cbind(res.nest.famp$V1[idx], res.nest.famp$V8[idx])
idx = res.nest.famp$p8 >= sim.cutoff
edges = rbind(edges, cbind(res.nest.famp$V8[idx], res.nest.famp$V1[idx]))


te.enges.names = unique(c(edges[,1], edges[,2]))
te.enges.fam = sapply(te.enges.names, function(s) strsplit(s, '\\|')[[1]][9] )
te.enges.fam[te.enges.fam %in% c('DNA/Pogo', 'DNA/Tc1', 'DNA/Harbinger', 'DNA/En-Spm',
                     'DNA/HAT', 'DNA', 'DNA/Mariner')] = 'DNA'
te.enges.fam[te.enges.fam %in% c('RathE1_cons', 'RathE2_cons', 'RathE3_cons')] = 'RathE1/2/3_cons'
te.enges.fam[te.enges.fam %in% c('LINE/L1', 'LINE?')] = 'LINE'
te.enges.fam[te.enges.fam %in% c('Unassigned')] = 'Mix'
te.enges.fam[te.enges.fam %in% c('RC/Helitron')] = 'Helitron'

g.part <- network(edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
b.graph.names = network.vertex.names(g.part)
b.graph.len = as.numeric(sapply(strsplit(b.graph.names, "\\|"), function(x) x[5]))


label.family = sapply(strsplit(b.graph.names, "\\|"), function(x) x[8])
lab.cols = c('#3F2E3E', "white")
label.color = lab.cols[(label.family == one.te.fam) + 1]

set.seed(20)
p <- ggnet2(g.part, label = b.graph.len, edge.color = "black", 
             node.size = 15,
            alpha=0.8,
            arrow.gap = 0.015,
            arrow.size = 5,
            label.color = label.color,
            # node.size = g.nodes.cnt[b.graph.names], 
            color = te.enges.fam[b.graph.names],
            palette = fam.palette,
            # mode = "kamadakawai"
            ) + guides(size = F)
p 

pdf(paste(path.figures, 'real_tes_subfam_', one.te.fam, '.pdf', sep = ''), width = 20, height = 18)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

set.seed(20)
p <- ggnet2(g.part, label = b.graph.names, edge.color = "black",
             node.size = 15,
            alpha=0.8,
            arrow.gap = 0.015,
            arrow.size = 5,
            # label.color = label.color,
            # node.size = g.nodes.cnt[b.graph.names],
            color = te.enges.fam[b.graph.names],
            palette = fam.palette,
            # mode = "kamadakawai"
            ) + guides(size = F)

pdf(paste(path.figures, 'real_tes_subfam_', one.te.fam, '_names.pdf', sep = ''), width = 50, height = 49)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

```


## Dotplots

### Read TE sequences
```{r}
file.te.fasta = paste(path.tair, 'new_te.fasta', sep = '')
te.fasta = seqinr::read.fasta(file.te.fasta)
te.names = names(te.fasta)
te.fasta = seqinr::getSequence(te.fasta)
names(te.fasta) = te.names
```

### One pairwise example
```{r}
wsize = 10
nmatch = 8

seq1 = te.fasta[[b.graph.names[1]]]
seq2 = te.fasta[[b.graph.names[1]]]


name1 = 'te|12384763|12385262|4|500|+|AT4TE57580|BRODYAGA1A|DNA/MuDR'
name2 = 'te|13674917|13675271|1|355|+|AT1TE44760|BRODYAGA1|DNA/MuDR'

# name1 = 'te|10592111|10592664|1|554|-|AT1TE34265|BRODYAGA2|DNA/MuDR'
# name2 = 'te|8743238|8744263|4|1026|-|AT4TE39045|HELITRONY1D|RC/Helitron'

name1 = 'te|6283198|6284421|4|1224|-|AT4TE26710|ATREP15|RC/Helitron'
name2 = 'te|6283198|6284421|4|1224|-|AT4TE26710|ATREP15|RC/Helitron'

seq1 = te.fasta[[name1]]
seq2 = te.fasta[[name2]]

p = dotplot(seq1, seq2, wsize, nmatch)

p = p + annotate("text", x = -Inf, y = Inf, label = paste('wsize=',wsize,'\nnmatch=',nmatch, sep = ''), 
             hjust = -0.1, vjust = 1.1)

p

pdf(paste(path.figures, 'pairwise_','.pdf', sep = ''), width = 5, height = 5)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()


```

### one VS all
```{r}

wsize = 10
nmatch = 8

name0 = 'te|11683565|11689821|3|6257|+|AT3TE48540|ATCOPIA95|LTR/Copia'
name0 = 'te|16691748|16695154|1|3407|−|AT1TE55070|ATCOPIA41|LTR/Copia'
name0 = gsub('−', "-", name0)


one.te.fam = strsplit(name0, '\\|')[[1]][8]
# one.te.fam = 'BRODYAGA2'
query.fam = df.query$query[df.query$subfam == one.te.fam]
query.fam = query.fam[(query.fam %in% res.nest.sim$V1) | (query.fam %in% res.nest.sim$V2)]

names.all = setdiff(query.fam, name0)

p.all = list()
for(name2 in names.all){
  # message(name2)
  seq1 = te.fasta[[name0]]
  seq2 = te.fasta[[name2]]
  
  s1 = strsplit(name0, '\\|')[[1]][7]
  s2 = strsplit(name2, '\\|')[[1]][7]
  p = dotplot(seq1, seq2, wsize, nmatch) + xlab(s1) + ylab(s2)
  p.all[[name2]] = p
}
# 
# pp = grid.arrange(grobs = p.all, ncol = 13) ## display plot
# 
# 
# pdf(paste(path.figures, 'pairwise_all','.pdf', sep = ''), width = 50, height = 50)
# print(pp)     # Plot 1 --> in the first page of PDF
# dev.off()

s0 = paste0(strsplit(name0, '\\|')[[1]][7:9], collapse = '_')
s0 = gsub("/", "-", s0)
pdf(paste(path.figures, 'pairwise_all_',s0,'.pdf', sep = ''), width = 50, height = 50)
grid.arrange(grobs = p.all, ncol = ceiling(sqrt(length(p.all)))) # Write the grid.arrange in the file
dev.off() # Close the file

```


### one connected component
```{r}

wsize = 10
nmatch = 8


name0 = 'te|6205621|6206184|2|564|−|AT2TE25255|HELITRONY1D|RC/Helitron'
name0 = 'te|14189256|14190266|5|1011|-|AT5TE50700|HELITRONY3|RC/Helitron'
name0 = 'te|12513239|12513824|1|586|+|AT1TE40725|ATHILA4A|LTR/Gypsy'
name0 = 'te|11647426|11648912|1|1487|+|AT1TE37705|ATREP7|RC/Helitron'
name0 = 'te|11683565|11689821|3|6257|+|AT3TE48540|ATCOPIA95|LTR/Copia'
name0 = gsub('−', "-", name0)


names.all = unique(c(res.nest.sim$V1[res.nest.sim$V8 == name0],
                     res.nest.sim$V8[res.nest.sim$V1 == name0]))
# names.all = unique(c(res.nest$V1[res.nest$V8 == name0], 
#                      res.nest$V8[res.nest$V1 == name0]))

p.all = list()
for(name2 in names.all){
  # message(name2)
  seq1 = te.fasta[[name0]]
  seq2 = te.fasta[[name2]]
  
  s1 = paste0(strsplit(name0, '\\|')[[1]][7:9], collapse = '|')
  s2 = paste0(strsplit(name2, '\\|')[[1]][7:9], collapse = '|')
  p = dotplot(seq1, seq2, wsize, nmatch) + xlab(s1) + ylab(s2)
  p.all[[name2]] = p
}


s0 = paste0(strsplit(name0, '\\|')[[1]][7:9], collapse = '_')
s0 = gsub("/", "-", s0)
pdf(paste(path.figures, 'pairwise_connect_',s0,'.pdf', sep = ''), width = 50, height = 50)
grid.arrange(grobs = p.all, ncol = ceiling(sqrt(length(p.all)))) # Write the grid.arrange in the file
dev.off() # Close the file

```



```{r}


name1 = 'te|14189256|14190266|5|1011|-|AT5TE50700|HELITRONY3|RC/Helitron'
name2 = 'te|2162295|2162937|2|643|-|AT2TE09950|HELITRONY3|RC/Helitron'
name0 = name1

names.all = unique(c(res.nest$V1[res.nest$V8 == name0], res.nest$V8[res.nest$V1 == name0]))


names = c(name1, name2)
b.tmp = bl.res[(bl.res$V1 %in% names) & (bl.res$V8 %in% names),]

res.nest[(res.nest$V1 %in% names) & (res.nest$V8 %in% names), ]

```


# SVs
## Readings seSVs
```{r}

sv.se = readRDS(paste(path.svs, 'sv_se.rds', sep = ''))

# Rename length groups
lev.replace = c('[1,10]', '(10,15]')
lev.new = '[1,15]'

s.levels = as.character(levels(sv.se$len.gr))
s.levels = s.levels[!(s.levels %in% lev.replace)]
s.levels = c(lev.new, s.levels)
s.levels = gsub("e\\+03", "k", s.levels)

sv.se$len.gr = as.character(sv.se$len.gr)
sv.se$len.gr[sv.se$len.gr %in% lev.replace] = lev.new
sv.se$len.gr = gsub("e\\+03", "k", sv.se$len.gr)
sv.se$len.gr = factor(sv.se$len.gr, levels = s.levels)


# Replace families
sv.se$fam = as.character(sv.se$fam)
sv.se$fam <- gsub("Helitron/.*", "Mix with Helitron", sv.se$fam)


sv.se$te = factor(sv.se$te, levels = c('isTE', 'isTEpart', 'hasTE', 'hasTEpart', 'noTE'))

sv.seqs = readFastaMy(paste(path.svs, 'sv_pangen_seq_sv_big.fasta', sep = ''))

## GC estimate

rownames(sv.se) = sv.se$gr

sv.gc = c()
for(irow in 1:length(sv.seqs)){
  s = toupper(seq2nt(sv.seqs[irow]))
  sv.gc[irow] = sum((s == 'G') | (s == 'C'))
}
names(sv.gc) = sapply(names(sv.seqs), function(s) strsplit(s, '\\|')[[1]][1])


# Positions

sv.pos.beg = read.table(paste(path.svs, 'svs_all_beg_pos_v03.txt', sep = ''), 
                        stringsAsFactors = F, check.names = F)
sv.pos.end = read.table(paste(path.svs, 'svs_all_end_pos_v03.txt', sep = ''), 
                        stringsAsFactors = F, check.names = F)
sv.pos.bin = read.table(paste(path.svs, 'svs_se_bin_v03.txt', sep = ''), 
                        stringsAsFactors = F, check.names = F)

```


## Reading nestedness
```{r}

# Load similarity function

file.nestedness = paste(path.work, 'sv_big_on_big_nest.rds', sep = '')


if(!file.exists(file.nestedness)){
  bl.file = paste(path.work, 'sv_big_on_big.txt', sep = '')
  bl.res = read.table(bl.file)
  bl.res = bl.res[bl.res$V1 != bl.res$V8,]
  
  bl.res = bl.res[bl.res$V6 >= sim.cutoff * 100,]

  res.nest = findNestedness(bl.res, use.strand = F)
    
  res.nest$len1 = res.nest.len[res.nest$V1]
  res.nest$len8 = res.nest.len[res.nest$V8]
  res.nest$p1 = res.nest$C1 / res.nest$len1
  res.nest$p8 = res.nest$C8 / res.nest$len8  
  saveRDS(res.nest, file.nestedness, compress = F)
} else {
  res.nest = readRDS(file.nestedness)
}

res.nest.len = sapply(unique(c(res.nest$V1, res.nest$V8)), 
                      function(s) as.numeric(strsplit(s, '\\|')[[1]][2]))
res.nest0 = res.nest


# For further analysis of examples:
bl.file = paste(path.work, 'sv_big_on_big.txt', sep = '')
bl.res = read.table(bl.file)
bl.res = bl.res[bl.res$V1 != bl.res$V8,]

```



## TE stat

### In graph - not in graph
```{r}
res.nest = res.nest0

sv.se.len = sv.se[sv.se$len >= 100,]
sv.se.len$in.connect = sv.se.len$name %in% names(res.nest.len)


cnt.sv.se = table(sv.se.len$in.connect , sv.se.len$te)
cnt.sv.se

df = reshape2::melt(cnt.sv.se)



df$Var2 = factor(df$Var2, levels = rev(c('isTE', 'isTEpart', 'hasTE', 'hasTEpart', 'noTE')))


# install.packages("ggpattern")


p = ggplot(df, aes(x = Var2, y = value, fill = Var2, alpha = Var1, color = Var1)) +
  geom_col_pattern( aes(pattern = Var1),
    # pattern = rep(c('none', "stripe"), 5),
    pattern_density = 0.1,
    pattern_spacing = 0.025,
    pattern_fill = "grey70", 
    position = "dodge", 
    width = 0.8
  ) + 
  # geom_col(position = "dodge", width = 0.8) +
  scale_alpha_manual(values = c(0.8, 1), labels = c("No", "Yes")) +
  scale_color_manual(values = c('black', 'black'), labels = c("not in graph", "in graph")) +
  scale_pattern_manual(values = c("stripe", 'none'), labels = c("in graph", "not in graph"),
                       breaks = c(TRUE, FALSE)) +
  labs(fill = "", pattern='Connected to others') +
  scale_fill_manual(values = te.cols) +
  xlab(NULL) +
  ylab("Number of SVs") +
  theme(axis.text.y = element_blank()) + 
  guides(alpha = "none", fill = 'none', color = 'none') +
  theme_minimal() + coord_flip() +
  theme(
    legend.position = c(0.7, 0.3),     # Adjust these coordinates as needed
    legend.background = element_rect(fill="transparent", color='grey70')  
  ) +
  # scale_y_continuous(breaks = levels(df$Var2),
  #                    labels = c('a', 'b', 'c', 'd', 'e')) +
  # theme(axis.text.y = c('a', 'b', 'c', 'd', 'e')) +
  guides(pattern = guide_legend(override.aes = list(fill = c("white"), color= 'black')))  
p

pdf(paste(path.figures, 'graph_mob_in_graph.pdf', sep = ''), width = 5, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

```
### Save "in graph data"
```{r}

df.bin = sv.pos.bin[rownames(sv.se.len)[sv.se.len$in.connect],]
rownames(df.bin) = sv.se.len[rownames(df.bin),]$name

sv.names.in.graph = rownames(df.bin)

saveRDS(df.bin, paste(path.work,'sv_bin_ingraph.rds', sep = ''))
```



### Stat for the paper
```{r}
df.te = df[df$Var2 != 'noTE',]


if(sum(df.te[!df.te$Var1,]$Var2 != df.te[df.te$Var1,]$Var2) == 0){
  pokaz('Ratios', as.character(df.te[!df.te$Var1,]$Var2))
  pokaz(df.te[!df.te$Var1,]$value / df.te[df.te$Var1,]$value )
} else {
  stop('Something is wrong with the names.')
}


```


### TE families in SV types
```{r}

sv.se.len = sv.se[sv.se$len >= 100,]
cnt.fam.sv = table(sv.se.len$fam[sv.se.len$fam!=''], sv.se.len$te[sv.se.len$fam!=''])
cnt.fam.sv = t(apply(cnt.fam.sv, 1, function(x) x/sum(x)))
cnt.fam.sv = cnt.fam.sv[, colSums(cnt.fam.sv) != 0]
cnt.fam.sv = reshape2::melt(cnt.fam.sv)

p = ggplot(cnt.fam.sv, aes(x = Var2, y = Var1, color = Var2)) + 
  geom_point(aes(size = value, 
                 alpha = value * 2
                 )) + theme_minimal() + 
  scale_color_manual(values = te.cols)  +
  geom_text(data = cnt.fam.sv[cnt.fam.sv$value >= 0.2,], 
              aes(x=Var2, y=Var1, label = round(value, 2)), 
              size = 2.5, color = 'black', 
            nudge_x = 0.3,
            nudge_y = 0) +
  guides(size = "none", alpha = "none", color = 'none') +
  xlab('SV type') + ylab('TE family')
p


cnt.fam.sv = rowSums(table(sv.se.len$fam[sv.se.len$fam!=''], sv.se.len$te[sv.se.len$fam!='']))
cnt.fam.sv = data.frame(value = cnt.fam.sv, names = names(cnt.fam.sv))
rownames(cnt.fam.sv) = NULL

g = ggplot(cnt.fam.sv, aes(x = names, y = value)) +
  geom_bar(stat="identity", fill="grey80")+
  coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(),
                        axis.text.y = element_blank(),
                        axis.ticks.y = element_blank()) +
  scale_y_continuous(labels = paste("1e",seq(0,4,1), sep = ''), breaks= seq(0,4,1)*1000) +
  ylab('#') + geom_text(aes(label=value, y=0), hjust=0, size = 2.5)
g 


pp = ggpubr::ggarrange(p + xlab('TE content') + scale_x_discrete(labels = c('is compl.', 'is fragm.', 
                               'cont. compl.', 'cont. fragm.')) , g, ncol = 2, widths = c(0.75, 0.25))
pp

# pdf(paste(path.figures, 'graph_mob_te_fam_sv_type.pdf', sep = ''), width = 6, height = 4)
# print(pp)     # Plot 1 --> in the first page of PDF
# dev.off()


# Insertion and deletion
idx = (sv.se.len$fam!='') & (sv.se.len$freq.max <= 3)
table(sv.se.len$fam[idx], sv.se.len$te[idx])

idx = (sv.se.len$fam!='') & (sv.se.len$freq.max >= 25) & (sv.se.len$len >= 100) 
table(sv.se.len$fam[idx], sv.se.len$te[idx])
```



### TE fam: TAIR10
```{r}
f.te.ref = paste(path.tair, 'new_te.fasta', sep = '')
lines = readLines(f.te.ref)
lines = grep('^>', lines, value = T)

ref.fam = sapply(lines, function(x) strsplit(x, '\\|')[[1]][9])


indices <- grep("^DNA(?!/HAT|/MuDR)", ref.fam, value = FALSE, perl = TRUE)
ref.fam[indices] = 'DNA+'

indices <- grep("^RathE", ref.fam, value = FALSE, perl = TRUE)
ref.fam[indices] = 'RathE1/2/3_cons'

indices <- grep("^LINE", ref.fam, value = FALSE, perl = TRUE)
ref.fam[indices] = 'LINE'
ref.fam[ref.fam == 'RC/Helitron'] = 'Helitron'

ref.fam.cnt = table(ref.fam)



df = cnt.fam.sv
df$ref = as.numeric(ref.fam.cnt[df$names])
df = df[!is.na(df$ref),]

plot(df$value, df$ref)



p <- ggplot(df, aes(x = ref, y = value, color = names)) +
  geom_smooth(aes(group = 1), method = "lm", formula = y ~ x, se = FALSE, color = 'grey70') + 
  geom_point() +
  ggrepel::geom_text_repel(aes(label = names), max.overlaps = 20) +
  # xlab("log # in TAIR10 annotation") +
  # ylab("log # in SVs") +
  # scale_x_log10() +
  # scale_y_log10() +
  xlab("# in TAIR10 annotation") +
  ylab("# in SVs") +
  theme(legend.position = "none") +
  guides(color = FALSE) +
  theme_minimal()
p


lm_model <- lm(value ~ ref, data = df)
slope <- coef(lm_model)[2]


p = p + annotate("text", x = min(df$ref), y = max(df$value), 
           label = paste('Slope:', round(slope, 3)), hjust = 0, vjust = 1)


# 
# pdf(paste(path.figures, 'graph_mob_te_fam_tair10.pdf', sep = ''), width = 4, height = 4)
# print(p)     # Plot 1 --> in the first page of PDF
# dev.off()


```


## Bridges
```{r}

head(sv.se.len)
rownames(sv.se.len) = sv.se.len$name

head(bl.res)

df.nest = res.nest

df.nest$f1 = sv.se.len[df.nest$V1,]$fam
df.nest$f8 = sv.se.len[df.nest$V8,]$fam

df.nest$f1[is.na(df.nest$f1)] = ''
df.nest$f8[is.na(df.nest$f8)] = ''

df.nest = df.nest[df.nest$f1 != df.nest$f8,]

df.nest = df.nest[df.nest$f1 != 'Helitron',]
df.nest = df.nest[df.nest$f8 != 'Helitron',]

df.nest = df.nest[df.nest$f1 != 'TEG',]
df.nest = df.nest[df.nest$f8 != 'TEG',]

df.nest = df.nest[(df.nest$p1 > 0.8) | (df.nest$p8 > 0.8),]
df.nest = df.nest[(df.nest$len1 > 100) & (df.nest$len8 > 100),]

df.nest = df.nest[(df.nest$p1 > 0.8) | (df.nest$p8 > 0.8),]
df.nest = df.nest[(df.nest$len1 > 1000) | (df.nest$len8 > 1000),]

sv.no.te = unique(c(df.nest$V1[df.nest$f1 == ''], df.nest$V8[df.nest$f8 == '']))
sv.name = sv.no.te[1]

sv.name.found = c()
for(sv.name in sv.no.te){
  df.tmp = df.nest[(df.nest$V1 == sv.name) | (df.nest$V8 == sv.name),]
  if (length(unique(c(df.tmp$f1, df.tmp$f8))) > 2) sv.name.found = c(sv.name.found, sv.name)
  
}

k = 15
sv.name = sv.name.found[k]
df.tmp = df.nest[(df.nest$V1 == sv.name) | (df.nest$V8 == sv.name),]
head(df.tmp)


```



```{r}
name1 = 'SVgr_1_id_75710|141'
name2 = 'SVgr_2_id_90768|5720'
dotplot.s(sv.seqs[name1], sv.seqs[name2], 15, 12)

name3 = 'SVgr_1_id_76841|15640'
dotplot.s(sv.seqs[name1], sv.seqs[name3], 15, 12)

dotplot.s(sv.seqs[name3], sv.seqs[name2], 15, 12)


name4 = 'SVgr_3_id_77360|16138'
dotplot.s(sv.seqs[name3], sv.seqs[name4], 15, 12)


```


```{r}
name1 = 'SVgr_1_id_115061|1207'
name2 = 'SVgr_1_id_126768|3181'
dotplot.s(sv.seqs[name1], sv.seqs[name2], 15, 12)

name3 = 'SVgr_1_id_71204|9005'
dotplot.s(sv.seqs[name1], sv.seqs[name3], 15, 12)

dotplot.s(sv.seqs[name3], sv.seqs[name2], 15, 12)


```



## Graph creation

```{r}

sv.graph = getGraphFromBlast(res.nest=res.nest, 
                             sim.cutoff = sim.cutoff,
                             collapse = T)

sv.graph.full = getGraphFromBlast(res.nest=res.nest, 
                             sim.cutoff = sim.cutoff,
                             collapse = F)

sv.graph$nodes$type = setNames(sv.se$te, sv.se$name)[sv.graph$nodes$name]
sv.graph$nodes$fam = setNames(sv.se$fam, sv.se$name)[sv.graph$nodes$name]
sv.graph$nodes$freq = setNames(sv.se$freq.max, sv.se$name)[sv.graph$nodes$name]
sv.graph$nodes$len = as.numeric(sapply(sv.graph$nodes$name, function(s) strsplit(s, '\\|')[[1]][2]))

sv.graph$nodes.traits$type <- traitsSeqToNode(sv.graph$nodes, 
                                              setNames(sv.graph$nodes$type, sv.graph$nodes$name),
                                              mode = 'maxunique'
                                              )[sv.graph$nodes.traits$node]
sv.graph$nodes.traits$fam <- traitsSeqToNode(sv.graph$nodes[sv.graph$nodes$fam != '',], 
                                              setNames(sv.graph$nodes$fam[sv.graph$nodes$fam != ''], 
                                                       sv.graph$nodes$name[sv.graph$nodes$fam != '']),
                                              mode = 'maxunique'
                                              )[sv.graph$nodes.traits$node]

sv.graph$nodes.traits$freq <- round(traitsSeqToNode(sv.graph$nodes, 
                                              setNames(sv.graph$nodes$freq, sv.graph$nodes$name),
                                              mode = 'mean'
                                              )[sv.graph$nodes.traits$node])

sv.graph$nodes.traits$len <- round(traitsSeqToNode(sv.graph$nodes, 
                                              setNames(sv.graph$nodes$len, sv.graph$nodes$name),
                                              mode = 'mean'
                                              )[sv.graph$nodes.traits$node])

# indels
sv.se$freq = sv.se$freq.max
n.cutoff = 3
n = 28
sv.se$sin = 'M'
sv.se$sin[sv.se$freq >= (n - n.cutoff)] = 'D'
sv.se$sin[sv.se$freq <= n.cutoff] = 'I'


sv.graph$nodes$indel = setNames(sv.se$sin, sv.se$name)[sv.graph$nodes$name]

sv.graph$nodes.traits$indel <- traitsSeqToNode(sv.graph$nodes, 
                                              setNames(sv.graph$nodes$indel, sv.graph$nodes$name),
                                              mode = 'unique',
                                              explain.mix = F,
                                              mix.word = 'M'
                                              )[sv.graph$nodes.traits$node]

```
### EXAMPLE: MIX
```{r}

# Find a bridge-node

edges.fam = cbind(sv.graph$nodes.traits[sv.graph$edges[,1],]$fam, 
                  sv.graph$nodes.traits[sv.graph$edges[,2],]$fam)

edges.fam = cbind(edges.fam, sv.graph$edges[,])
edges.fam = edges.fam[rowSums(is.na(edges.fam)) == 0,]

edges.fam = edges.fam[edges.fam[,1] != edges.fam[,2],]
edges.fam = edges.fam[order(edges.fam[,3]),]

idx.inner = idxDuplicates(edges.fam[,3])

edges.fam.target = edges.fam[idx.inner,]
edges.fam.target = edges.fam.target[order(edges.fam.target[,3]),]


N8
R3251
N1031
R3264




node0 = 'R2862' #no
node0 = 'R2886' #no
node0 = 'N119' #no
node0 = 'N790' # no

node0 = 'R1541'

node0 = 'R1516'
node0 = 'N1010'

node0 = 'N141' # very good

node0 = 'R2315'

node0 = 'R411' # maybe interesting
node0 = 'R500' # helitron family

node0 = 'R777' # more or less



node0.in = edges.fam.target[edges.fam.target[,3] == node0,4]

sv1 = sv.graph$nodes$name[sv.graph$nodes$node == node0.in[1]][1]
sv2 = sv.graph$nodes$name[sv.graph$nodes$node == node0.in[2]][1]
sv0 = sv.graph$nodes$name[sv.graph$nodes$node == node0][1]

pokaz(sv0, sv1, sv2)


dotplot.s(sv.seqs[sv1], sv.seqs[sv2], 15, 12)

dotplot.s(sv.seqs[sv0], sv.seqs[sv1], 15, 12)
dotplot.s(sv.seqs[sv0], sv.seqs[sv2], 15, 12)

dotplot.s(sv.seqs[sv1], sv.seqs[sv1], 15, 12)
dotplot.s(sv.seqs[sv2], sv.seqs[sv2], 15, 12)

# sv.on.te = read.table(paste(path.work, 'blast_sv_on_tes.txt', sep = ''), stringsAsFactors = F)


df = sv.on.te[sv.on.te$V1 == sv2,c('V2', 'V3', 'V8'),]
colnames(df) = c('beg', 'end', 'V8')
df$fam = sapply(df$V8, function(s) strsplit(s, '\\|')[[1]][9])
orfplot(df, s.color = 'fam', show.legend = T, arrow.size = 0) + 
  scale_colour_manual(values = fam.palette) 

df = sv.on.te[sv.on.te$V1 == sv1,c('V2', 'V3', 'V8'),]
colnames(df) = c('beg', 'end', 'V8')
df$fam = sapply(df$V8, function(s) strsplit(s, '\\|')[[1]][9])
orfplot(df, s.color = 'fam', show.legend = T, arrow.size = 0) + 
  scale_colour_manual(values = fam.palette) 


orfFinder(sv.seqs[sv2])

```

#### Examples from connected components
```{r}

```


#### On server
```{r}

sv.se[sv.se$name ==sv2,]

path.work = '../cmp_all/'

x = readRDS(paste(path.work, 'val_common_chr_4_ref_add.rds', sep = ''))
p1 = which(x[,1] == 11012289)
p2 = which(x[,1] == 11021812)

p1 = 11012289
p2 = 11021812
p1
p2

path.out = paste(path.work, 'examples/', sep = '')
if (!file.exists(path.out))  dir.create(path.out)

i.chr = 4
file = paste(path.work,'seq_aln_chr_',i.chr,'_ref_add.rds', sep = '')
s.init = readRDS(file)

n.window = 1000
# n.window = 0
pos = (p1-n.window):(p2+n.window)

s = s.init[pos,]
f.fasta = paste(path.out,  'example_',sv2,'_wind_',n.window,'.fasta', sep = '')
print('Write')
write('', file=f.fasta, append=F)
for(i in 1:ncol(s)){
  # print(i)
  s.tmp = unlist(s[,i])
  write(paste('>acc_', colnames(x)[i], sep = ''), file=f.fasta, append=T)
  write(toupper(paste0(s.tmp, collapse = '')), file=f.fasta, append=T)
}

v.wnd = x[pos,]
f.pos = paste(path.out,  'example_',sv2,'_wind_',n.window,'.rds', sep = '')
saveRDS(v.wnd, f.pos)


x[c(min(pos), max(pos)),1]
# [1] 17476332 17496274

```


### Filtration
```{r}


sv.graph$nodes.traits = sv.graph$nodes.traits[!grepl("^Mix", sv.graph$nodes.traits$fam), ]
sv.graph$nodes.traits = sv.graph$nodes.traits[sv.graph$nodes.traits$fam != 'noTE',]
nodes.remain = sv.graph$nodes.traits$node
sv.graph$edges = sv.graph$edges[sv.graph$edges[,1] %in% nodes.remain, ]
sv.graph$edges = sv.graph$edges[sv.graph$edges[,2] %in% nodes.remain, ]


# 
# res.nest = res.nest0
# 
# sv.names.mix = sv.se$name[grep("^Mix", sv.se$fam)]
# res.nest = res.nest[!(res.nest$V1 %in% sv.names.mix),]
# res.nest = res.nest[!(res.nest$V8 %in% sv.names.mix),]
# 
# 
# sv.names.mix = sv.se$name[sv.se$te == 'noTE']
# res.nest = res.nest[!(res.nest$V1 %in% sv.names.mix),]
# res.nest = res.nest[!(res.nest$V8 %in% sv.names.mix),]
# 
# singleton.mode = F
# if(singleton.mode){
#   sv.names.freq = sv.se$name[sv.se$freq.max <= 3]
#   # sv.names.freq = sv.se$name[sv.se$freq.max >= 25]
#   res.nest = res.nest[res.nest$V1 %in% sv.names.freq,]
#   res.nest = res.nest[res.nest$V8 %in% sv.names.freq,]
# }
# 
# prefix.mode = c('', '_single')


```



### Plot te-type
```{r}
g.part <- network(sv.graph$edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.names = network.vertex.names(g.part)


g.part %v% "colors" = as.character(sv.graph$nodes.traits[g.part.names,]$type)
g.part %v% "node.size" = sv.graph$nodes.traits[g.part.names,]$cnt

set.seed(20)
p <- ggnet2(g.part, label = F, edge.color = "black",
            node.size =  "node.size",
            # node.size = 1,
            # color = '#468B97',
            # arrow.gap = 0.01, arrow.size = 2,
            color = "colors",
            palette = te.cols
            # mode = "kamadakawai"
            ) + guides(size=F)

p = p + guides(size = F) 
p = p + coord_fixed(ratio = 1)
p



pdf(paste(path.figures, 'graph_mob_all_cluster_type.pdf', sep = ''), 
    width = 4.6, height = 4.6)
print(p+ theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()
```


### Colored by TE family
```{r}
g.part <- network(sv.graph$edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.names = network.vertex.names(g.part)
set.seed(20)

g.part %v% "colors" = as.character(sv.graph$nodes.traits[g.part.names,]$fam)
g.part %v% "node.size" = sv.graph$nodes.traits[g.part.names,]$cnt

p <- ggnet2(g.part, label = F, edge.color = "black",
            node.size = "node.size",
            # node.size = 1,
            # color = '#468B97',
            # arrow.gap = 0.01, arrow.size = 2,
            color = "colors",
            palette = fam.palette
            # mode = "kamadakawai"
            ) + guides(size=F)

p

pdf(paste(path.figures, 'graph_mob_all_cluster','_family.pdf', sep = ''), 
    width = 4.6, height = 4.6)
print(p+ theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()


pdf(paste(path.figures, 'graph_mob_all_cluster','_family_legend.pdf', sep = ''), width = 7, height = 5)
print(p+ coord_fixed(ratio = 1))     # Plot 1 --> in the first page of PDF
dev.off()


```




### Node size distribution
```{r}


p = ggplot(sv.graph$nodes.traits, aes(x = type, y = cnt, color=fam)) +
  geom_jitter(width = 0.2) +
  labs(x = "Type", y = "Size") + 
  scale_y_continuous(trans = "log2") +
  scale_color_manual(values = fam.palette)+
  theme_minimal() +
  guides(color = guide_legend(ncol = 2)) +
  labs(color = "TE family") + xlab('') + ylab('Node size (Number of similar SVs)')
p


pdf(paste(path.figures, 'graph_mob_size_distribution.pdf', sep = ''), width = 6.5, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

```



### Separately visualise connected components
```{r}

# Get components
g.comp <- getGraphComponents(sv.graph$edges)

g.comp.cnt = table(g.comp$membership)
g.comp.cnt = -sort(-g.comp.cnt)
head(g.comp.cnt)

# ------------------------------------
# The biggest component
# ------------------------------------
k = 1
comp.id = as.numeric(names(g.comp.cnt)[k])


comp.names = names(g.comp$membership)[g.comp$membership == comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)

# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = sv.graph$nodes.traits[g.part.sub.big.names,]$cnt, 
            color = sv.graph$nodes.traits[g.part.sub.big.names,]$type,
            mode = 'kamadakawai',
            palette = te.cols) + guides(size = F)
p.big.type = p + theme(legend.position = "none")

set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = sv.graph$nodes.traits[g.part.sub.big.names,]$cnt, 
            color = sv.graph$nodes.traits[g.part.sub.big.names,]$fam,
            mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F)
p.big.color = p + theme(legend.position = "none")

# ------------------------------------
# Small components
# ------------------------------------

# Construct the graph object
comp.names = names(g.comp$membership)[g.comp$membership != comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)

# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = sv.graph$nodes.traits[g.part.sub.big.names,]$cnt, 
            color = sv.graph$nodes.traits[g.part.sub.big.names,]$type,
            # mode = 'kamadakawai',
            palette = te.cols) + guides(size = F)
p.small.type = p + theme(legend.position = "none")

set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = sv.graph$nodes.traits[g.part.sub.big.names,]$cnt, 
            color = sv.graph$nodes.traits[g.part.sub.big.names,]$fam,
            # mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F)
p.small.color = p + theme(legend.position = "none")



```

#### Save
```{r}
# p.big.type
# p.big.color
# p.small.type
# p.small.color

size.units = 4.6

pdf(paste(path.figures, 'graph_mob_big_cluster', prefix.mode[singleton.mode+1] ,'_type.pdf', sep = ''), 
    width = size.units, height = size.units)
print(p.big.type)     # Plot 1 --> in the first page of PDF
dev.off()

pdf(paste(path.figures, 'graph_mob_big_cluster', prefix.mode[singleton.mode+1] ,'_family.pdf', sep = ''), 
    width = size.units, height = size.units)
print(p.big.color)     # Plot 1 --> in the first page of PDF
dev.off()

pdf(paste(path.figures, 'graph_mob_small_cluster', prefix.mode[singleton.mode+1] ,'_type.pdf', sep = ''), 
    width = 6, height = 6)
print(p.small.type)     # Plot 1 --> in the first page of PDF
dev.off()

pdf(paste(path.figures, 'graph_mob_small_cluster', prefix.mode[singleton.mode+1] ,'_family.pdf', sep = ''), 
    width = 6, height = 6)
print(p.small.color)     # Plot 1 --> in the first page of PDF
dev.off()



```




## Example SEPARATE components
```{r}
path.components = paste(path.figures, 'components_upd/', sep = '')
if (!dir.exists(path.components)) {
  dir.create(path.components)
}


# Run again if needed
# g.comp <- getGraphComponents(sv.graph$edges)

nodes.big = sv.graph$nodes.traits$node[(sv.graph$nodes.traits$cnt >= 5) ]
nodes.big = nodes.big[nodes.big %in% names(g.comp$membership)]  # I don't know why
id.node.the.biggest = which(g.comp$csize == max(g.comp$csize))
nodes.big = setdiff(nodes.big, names(g.comp$membership)[g.comp$membership == id.node.the.biggest])

# comp.target = sort(setdiff(unique(g.comp$membership[nodes.big]), comp.id))
comp.target = sort(unique(g.comp$membership[nodes.big]))


for(i.target in comp.target){
# for(i.target in comp.target[1:20]){
  
  # Visualise one component
  
  sub.names = names(g.comp$membership)[g.comp$membership == i.target]
  b.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% sub.names) | 
                                 (sv.graph$edges[,2] %in% sub.names),,drop=F]
  
  # PLOT FUNCTION
  pp = svplotMain(b.graph.sub, sv.graph, te.cols, fam.palette, indel.pallete,
                  i.target)
  
  # pp
  
  # TODO: third plot - frequency plot (three of colors: insertion, deletion, indel)
  
  pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_main.pdf', sep = ''), 
      width = 8, height = 3)
  print(pp)     # Plot 1 --> in the first page of PDF
  
  dev.off()
  
}



```

### TE annotation on members
```{r}

# i.target = 41

for(s.node in names(g.comp$membership[g.comp$membership == i.target])){
  pokaz('* ', s.node)
  pokaz(sv.graph$nodes$name[sv.graph$nodes$node == s.node])
}

```
### Info Visualisation
```{r}

# sv.on.te = read.table(paste(path.work, 'blast_sv_on_tes.txt', sep = ''), stringsAsFactors = F)
# te.seq = readFastaMy(paste(path.tair, 'new_te.fasta', sep = ''))

#41 
i.target = 184

for(i.target in comp.target){

  
  s.nodes.target = names(g.comp$membership[g.comp$membership == i.target])
  
  pp = svplotTwoNodes(s.nodes.target = s.nodes.target, 
                      sv.graph = sv.graph, 
                      g.comp = g.comp,
                      sv.on.te = sv.on.te, 
                      sv.seqs = sv.seqs, 
                      te.seq = te.seq,
                      fam.palette = fam.palette)
  
  pp$pp.stat
  pp$pp.te.orf
  
  pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_stat.pdf', sep = ''), 
        width = 8, height = 6)
  print(pp$pp.stat)
  dev.off()
  
  
  pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_te_orf.pdf', sep = ''), 
        width = 5.2, 
      # height = 2
      height = 5.2)
  print(pp$pp.te.orf)
  dev.off()

}


```






### Alignment
```{r}


path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
  dir.create(path.mafft)
}


# for(i.target in comp.target[20]){
for(i.target in 20){
# for(i.target in comp.target){
  comp.names = names(g.comp$membership)[g.comp$membership == i.target]
  
  sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
  
  seqs.target = sv.seqs[sv.name.target]
  seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
  seqs.target = seqs.target[order(-seqs.target.len)]
  sv.name.target = names(seqs.target)
  
  if(length(seqs.target) > 50){
    message(i.target)
    next
  }
  
  # Find orientations of sequences
  
  bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
  orientation.target = rep('.', length(seqs.target))
  names(orientation.target) = sv.name.target
  orientation.target[1] = '+'
  
  # TODO: define the first orientation by the longest ORF
  
  dir.seq = c('-', '+')
  
  for(i in 1:(length(orientation.target) - 1)){
    bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
    bl.tmp = bl.tmp[order(-bl.tmp$V7),]
    bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
    bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
    bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
    if(nrow(bl.tmp) == 0) next
    
    if(orientation.target[i] == '+'){
      orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
    }
    
    if(orientation.target[i] == '-'){
      orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
    }
    
    if(sum(orientation.target == '.') == 0) break
  }
  # 
  for(i in which(orientation.target == '-')){
    seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
  }
  
  seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
  seqs.target.msa <- DNAStringSet(seqs.target.msa)
  
  # alignment <- msa(seqs.target.msa)
  
  # Run the alignment
  tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
  aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
  writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
  
  system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
  
  alignment = readDNAStringSet(aln.fasta)
  
  seqs.mx = as.matrix(alignment)
  p.msa = msaplot(seqs.mx)
  
  p.msa = p.msa + annotate("text", x = -Inf, y = Inf, 
                                           label = i.target, hjust = 0, vjust = 1)
  
  rownames(sv.se) = sv.se$gr
  f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
  
  
  # pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''), 
  #     width = 6, height = 4)
  png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''), 
      width = 6, height = 4, units = "in", res = 300)
  print(p.msa)     # Plot 1 --> in the first page of PDF
  dev.off()
}

p.msa
```

### Alignment step-by step
```{r}
# Align all sequences within each node

# sv.name.target = nodes$te[nodes$node %in% tmp.names]

aln.nodes = list()
seqs.all.cons = c()
for(s.node in tmp.names){
  sv.name.node = nodes$te[nodes$node %in% s.node]
  seqs.name.node = seqs.target.msa[sv.name.node]
  
  if(length(sv.name.node) == 1){
    seqs.mx = as.matrix(seqs.name.node)
    aln.nodes[[s.node]] = seqs.mx
    seqs.all.cons[s.node] = as.character(seqs.name.node)
    next
  }
  
  tmp.fasta = paste(path.mafft, 'tmp.fasta', sep = '')
  aln.fasta = paste(path.mafft, 'aln.fasta', sep = '')
  writeXStringSet(seqs.name.node, filepath = tmp.fasta)
  
  system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
  
  alignment = readDNAStringSet(aln.fasta)[sv.name.node]
  seqs.mx = as.matrix(alignment)
  # msaplot(seqs.mx)
  
  # add consensus sequence

  cons.prof = seqinr::consensus(seqs.mx, method = 'profile')
  cons.prof = cons.prof[!(rownames(cons.prof) == '-'),]
  max.indexes <- apply(cons.prof, 2, which.max)
  cons.seq = rownames(cons.prof)[max.indexes]
  # seqs.mx = rbind(seqs.mx, cons.seq)
  
  aln.nodes[[s.node]] = seqs.mx
  seqs.all.cons[s.node] = paste0(cons.seq, collapse = '')
}

# Combine all seqs for the alignment
 
# Align consensuses
seqs.all.cons <- DNAStringSet(seqs.all.cons)

# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln.fasta', sep = '')
writeXStringSet(seqs.all.cons, filepath = tmp.fasta)

system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))

alignment = readDNAStringSet(aln.fasta)

seqs.mx.cons = as.matrix(alignment)
msaplot(seqs.mx.cons)

# Combine consensuses back
seqs.mx.complete = c()
for(s.node in rownames(seqs.mx.cons)){
  aln.tmp = aln.nodes[[s.node]]
  mx.tmp = matrix('-', nrow = nrow(aln.tmp), ncol = ncol(seqs.mx.cons), dimnames = list(rownames(aln.tmp), NULL))
  mx.tmp[, seqs.mx.cons[s.node,] != '-'] = aln.tmp
  seqs.mx.complete = rbind(seqs.mx.complete, mx.tmp)
}

p.msa = msaplot(seqs.mx.complete[sv.name.target,])
# p.msa = msaplot(seqs.mx.complete)
p.msa


pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.pdf', sep = ''), 
    width = 6, height = 4)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()

```


## Example: MIX - 2
```{r}

path.components.mix = paste(path.figures, 'components_mix/', sep = '')
if (!dir.exists(path.components.mix)) {
  dir.create(path.components.mix)
}


s.sv = 'SVgr_1_id_12669|930'

s.node = sv.graph$nodes[s.sv,]$node
s.sv.other = sv.graph$nodes$name[sv.graph$nodes == s.node]

sv.graph$nodes.traits[s.node,]

i.target = g.comp$membership[s.node]

n.depth = 2
nodes.sub = s.node
for(i.depth in 1:n.depth){
  nodes.sub = unique(c(sv.graph$edges[(sv.graph$edges[,1] %in% nodes.sub) | 
                             (sv.graph$edges[,2] %in% nodes.sub),]))
}

edges.sub = sv.graph$edges[(sv.graph$edges[,1] %in% nodes.sub) & 
                             (sv.graph$edges[,2] %in% nodes.sub),]

pp = svplotMain(edges.sub, sv.graph, te.cols, fam.palette, indel.pallete)
pp

pdf(paste(path.components.mix, 
          'graph_around_', s.node,'_main.pdf', sep = ''), 
    width = 8, height = 3)
print(pp)
dev.off()



# TEs

df = sv.on.te[sv.on.te$V1 == s.sv, c('V1', 'V2', 'V3', 'V8'),]
df = sv.on.te[sv.on.te$V1 %in% s.sv.other, c('V1', 'V2', 'V3', 'V8'),]
colnames(df) = c('V1', 'beg', 'end', 'V8')
df$len = df$end - df$beg
df = df[df$len > 0.7 * nchar(sv.seqs[s.sv]),]

te1 = df$V8[df$len == max(df$len)][1]
df$fam = sapply(df$V8, function(s) strsplit(s, '\\|')[[1]][9])
po1 = orfplot(df, s.color = 'fam', show.legend = T, arrow.size = 0) + 
  scale_colour_manual(values = fam.palette) + 
  xlim(c(0, len1)) + labs(color = NULL) +
  geom_vline(xintercept=c(0, len1), color = 'black', linetype="dashed") +
  ggtitle(paste(n1, ':', sv1)) + theme(legend.position = "bottom") +
  theme(plot.title = element_text(size = 9))
po1



te1 = 'te|14189256|14190266|5|1011|-|AT5TE50700|HELITRONY3|RC/Helitron'
te2 = 'te|5743654|5744763|4|1110|+|AT4TE24100|HELITRONY3|RC/Helitron'
te3 = 'te|1370788|1371826|2|1039|-|AT2TE06255|SIMPLEHAT2|DNA/HAT'
te4 = 'te|743906|745157|5|1252|+|AT5TE02710|SIMPLEHAT2|DNA/HAT'

te.names = c(te1, te2, te3, te4)

df = df[df$V8 %in% te.names,]

combinations = t(matrix(c(1,3,1,4,2,3,2,4), nrow = 2))

p.list = list()
for(i.comb in 1:nrow(combinations)){
  tmp1 = te.names[combinations[i.comb,1]]
  tmp2 = te.names[combinations[i.comb,2]]
  p = dotplot(seq2nt(te.seq[tmp1]),
        seq2nt(te.seq[tmp2]), 15, 13)
  tmp1 = paste0(strsplit(tmp1, '\\|')[[1]][7:9], collapse = ', ')
  tmp2 = paste0(strsplit(tmp2, '\\|')[[1]][7:9], collapse = ', ')
  p.list[[length(p.list) + 1]] = p + xlab(tmp1) + ylab(tmp2)
}


sv1 = 'SVgr_1_id_41999|1308'
sv2 = 'SVgr_4_id_24460|1053'
dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv2]), 15, 13)


p.list = p.list[1:4]
for(i.te in 1:2){
  tmp1 = te.names[i.te]
  p = dotplot(seq2nt(te.seq[tmp1]),
              seq2nt(sv.seqs[sv2]), 15, 13)
  tmp1 = paste0(strsplit(tmp1, '\\|')[[1]][7:9], collapse = ', ')
  tmp2 = strsplit(sv2, '\\|')[[1]][1]
  p.list[[length(p.list) + 1]] = p + xlab(tmp1) + ylab(tmp2)
}

p.list = p.list[1:6]
for(i.te in 3:4){
  tmp1 = te.names[i.te]
  p = dotplot(seq2nt(sv.seqs[sv1]), 
              seq2nt(te.seq[tmp1]), 15, 13)
  tmp1 = paste0(strsplit(tmp1, '\\|')[[1]][7:9], collapse = ', ')
  tmp2 = strsplit(sv1, '\\|')[[1]][1]
  p.list[[length(p.list) + 1]] = p + ylab(tmp1) + xlab(tmp2)
}


p = dotplot(seq2nt(sv.seqs[sv1]), 
            seq2nt(sv.seqs[sv2]), 15, 13)
tmp1 = strsplit(sv1, '\\|')[[1]][1]
tmp2 = strsplit(sv2, '\\|')[[1]][1]
p.list[[length(p.list) + 1]] = p + xlab(tmp1) + ylab(tmp2)



  pp.te = invisible(ggarrange(p.list[[9]], p.list[[5]], p.list[[6]],
    
    p.list[[7]],
                              p.list[[1]],
                              p.list[[3]],
                              
                              
                              p.list[[8]],
                              
                               p.list[[2]],
                              p.list[[4]],
                                  nrow = 3, ncol = 3))
  
  
  pdf(paste(path.components.mix, 
          'graph_around_', s.node,'_tes.pdf', sep = ''), 
    width = 12, height = 12)
  
  
print(pp.te)
dev.off()

  



pp = svplotTwoNodes(s.nodes.target = nodes.sub, 
                    sv.graph = sv.graph, 
                    g.comp = g.comp,
                    sv.on.te = sv.on.te, 
                    sv.seqs = sv.seqs, 
                    te.seq = te.seq,
                    fam.palette = fam.palette,
                    n1 = 'N8')

pp$pp.stat
pp$pp.te.orf


```


# Stop
```{r}
stop('All graphs are created, Stop before the code for \"per accession\" ')
```



### Run by accessions
```{r}
path.figures.acc = '/Volumes/Samsung_T5/vienn/work_te/figures_tegraph_accessions/'
sv.bin = read.table('/Volumes/Samsung_T5/vienn/work_sv/svs_se_bin_v03.txt', stringsAsFactors = F, check.names = FALSE)
```


```{r}
# acc = '10002'

for(acc in colnames(sv.bin)){
  sv.acc = rownames(sv.bin)[sv.bin[,acc] == 1]
  rownames(sv.se) = sv.se$gr
  sv.acc = sv.se[sv.acc, 'name']
  
  sv.acc = intersect(sv.acc, rownames(nodes))
  nodes.cnt.acc = table(nodes[sv.acc,'node'])
  
  
  sv.alpha = rep(0, length(b.graph.names))
  names(sv.alpha) = b.graph.names
  sv.alpha[names(sv.alpha) %in% names(nodes.cnt.acc)] = 1
  
  # set.seed(239)
  # p <- ggnet2(g.part, label = F, edge.color = "black", 
  #             node.size = g.nodes.cnt[b.graph.names], 
  #             color = g.nodes.fam[b.graph.names],
  #             alpha = sv.alpha,
  #             # mode = 'kamadakawai',
  #             # arrow.gap = 0, 
  #             # arrow.size = 3,
  #             palette = fam.palette) + guides(size = F) + theme(legend.position = "none")
  
  set.seed(20)
  p <- ggnet2(g.part.sub.small, label = F, edge.color = "black", 
            node.size = g.nodes.cnt[b.graph.names.sub.small], 
            color = g.nodes.fam[b.graph.names.sub.small],
            alpha = sv.alpha[b.graph.names.sub.small],
            # mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F) + theme(legend.position = "none")

  pdf(paste(path.figures.acc, 'graph_te', prefix.mode[singleton.mode+1] ,'_small_acc_',acc,'.pdf', sep = ''), width = 5, height = 5)
  print(p)     # Plot 1 --> in the first page of PDF
  dev.off()
  
  
  set.seed(20)
  p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = g.nodes.cnt[b.graph.names.sub.big], 
            color = g.nodes.fam[b.graph.names.sub.big],
            alpha = sv.alpha[b.graph.names.sub.big],
            mode = 'kamadakawai',
            palette = fam.palette) + guides(size = F) + theme(legend.position = "none")

  pdf(paste(path.figures.acc, 'graph_te', prefix.mode[singleton.mode+1] ,'_big_acc_',acc,'.pdf', sep = ''), width = 5, height = 5)
  print(p)     # Plot 1 --> in the first page of PDF
  dev.off()

}

p 



```


```{r}
sv.annot = read.table('/Volumes/Samsung_T5/vienn/work_sv/svs_annotation_v03.txt', stringsAsFactors = F)
rownames(sv.annot) = sv.annot$gr
head(sv.annot)

sv.annot[extracted_values,]

```




# Big TE-nodes
```{r}
n.amount = 20

g.part <- network(b.graph, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
b.graph.names = network.vertex.names(g.part)

size.big = g.nodes.cnt[b.graph.names]
alpha.big = rep(1, length(b.graph.names))
names(alpha.big) = b.graph.names
alpha.big[size.big < n.amount] = 0

sum(size.big >= n.amount)

set.seed(20)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = size.big, 
            color = g.nodes.fam[b.graph.names],
            alpha= alpha.big,
            # mode = 'kamadakawai',
            # arrow.gap = 0, 
            # arrow.size = 3,
            palette = fam.palette) + guides(size = F) + guides(color = guide_legend(ncol = 2))
p

pdf(paste(path.figures, 'graph_small_cluster', prefix.mode[singleton.mode+1] ,'_family_amount.pdf', sep = ''), width = 5, height = 5)
print(p+ theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()





```

## Which families specifically, and is the rate of insertion is different?
compare number of insertions with the total number of TE load
```{r}

big.families = data.frame(node =  names(size.big)[size.big >= n.amount])
big.families$size = size.big[big.families$node]
big.families$fam = g.nodes.fam[big.families$node]
big.families = big.families[order(-big.families$size),]
rownames(big.families) = NULL

node.big = nodes[nodes$node %in% big.families$node,]

v = read.table(paste(path.work, 'blast_sv_on_tes.txt', sep = ''))
v = v[v$V1 %in% node.big$te,]


pos.len1 = 2
pos.len2 = 5
v1.len = sapply(unique(v$V1), function(s) as.numeric(strsplit(s,'\\|')[[1]][pos.len1]))
v8.len = sapply(unique(v$V8), function(s) as.numeric(strsplit(s,'\\|')[[1]][pos.len2]))
v.len = c(v1.len, v8.len)

v.sim = findNestedness(v, use.strand = F)

v.sim = findNestedness(v, use.strand = F)
v.sim$p1 = v.sim$C1 / v.len[v.sim$V1]
v.sim$p8 = v.sim$C8 / v.len[v.sim$V8]
v.sim$p1.in8 = v.sim$C1 / v.len[v.sim$V8]
v.sim$p8.in1 = v.sim$C8 / v.len[v.sim$V1]

node.big$subfam = ''
for(sv.name in unique(v.sim$V1)){
  v.tmp = v.sim[v.sim$V1 == sv.name,]
  s = v.tmp$V8[which.max(v.tmp$p1)]
  s = strsplit(s, '\\|')[[1]][8]
  node.big[sv.name, 'subfam'] = s
}


x = tapply(node.big$subfam, node.big$node, function(x){
  cnt = table(x)
  x = names(cnt)[cnt == max(cnt)]
  return(paste0(x, collapse =  ','))
})

big.families$subfam = x[big.families$node]


```



# no-TE SV
## Construct
```{r}


# sv.se = readRDS(paste(path.svs, 'sv_se.rds', sep = ''))

sv.se.no.te = sv.se$name[(sv.se$te == 'noTE') & (sv.se$len > 50)]

sv.seqs.no.te = sv.seqs[sv.se.no.te]
writeFastaMy(sv.seqs.no.te, paste(path.svs, 'sv_pangen_seq_no_te.fasta', sep = ''))

bl.file = paste(path.work,'sv_big_on_big.txt', sep = '')
bl.sv = read.table(bl.file, stringsAsFactors = F)
bl.sv = bl.sv[bl.sv$V1 != bl.sv$V8,]

# remove having TEs
bl.sv = bl.sv[bl.sv$V1 %in% sv.se.no.te, ]
bl.sv = bl.sv[bl.sv$V8 %in% sv.se.no.te, ]

pos.len = 2

sv.new = getGraphFromBlast(bl.res = bl.sv,
                           i.len.field = pos.len,
                             sim.cutoff = sim.cutoff,
                             collapse = F, 
                           refine = F,
                             return.nest = T,
                           max.length = 20000)

g.part <- network(sv.new$edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.names = network.vertex.names(g.part)

set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            # node.size = g.nodes.cnt[b.graph.names], 
            # color = g.nodes.type[b.graph.names],
            # palette = te.cols
            ) + guides(size = F)
p 


```

## Plot with colors
```{r}
sv.prot.init = readRDS(paste(path.work, 'sv_proteins_no_te_blast.rds', sep = ''))
sv.prot.init$name = sapply(sv.prot.init$X1, function(s){
  s = paste0(strsplit(s, '\\|')[[1]][1:2], collapse = '|')
  return(s)
})
sv.prot = sv.prot.init[sv.prot.init$prot == 1,]
sv.prot[,2] = tolower(sv.prot[,2])

types = c('disease', 'repeat', 'receptor',  'zinc', 'transcriptase', 'reverse', 'transpos')
for(i.type in 1:length(types)){
  sv.prot[,types[i.type]] = (grepl(types[i.type], sv.prot[,2])) * 1
}
sv.prot$type = rowSums(sv.prot[,types])
table(sv.prot$type)


sv.memb = data.frame(name = unique(c(sv.new$edges)))
rownames(sv.memb) = sv.memb$name

sv.memb$prot = 'no prot'
sv.memb$prot[sv.memb$name %in% sv.prot.init$name] = 'undefined prot'
sv.memb$prot[sv.memb$name %in% sv.prot$name] = 'defined prot'
for(type in types){
  sv.memb$prot[sv.memb$name %in% sv.prot$name[sv.prot[,type] == 1]] = type
}


sv.memb$prot[sv.memb$prot == 'disease'] = 'defined prot'

g.part %v% "colors" = sv.memb[g.part.names, 'prot']
set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "colors",
            palette = g.cols,
            # mode = "kamadakawai"
            ) + guides(size = F) + coord_fixed(ratio = 1) +
  scale_color_manual(values = g.cols, 
                       breaks = c("transpos","reverse",
                                  "repeat","zinc","receptor", "defined prot", "undefined prot",
                                  "no prot"), 
                     name = 'Protein key-word:') + theme(legend.justification = c(1, 0))
p = p+ theme(legend.key.height = unit(0.5, "cm"))
p

# pdf(paste(path.figures, 'graph_new_all.pdf', sep = ''), width = 6, height = 4)
# print(p)     # Plot 1 --> in the first page of PDF
# dev.off()


# 
# cnt = table(g.nodes.prot)
# cnt = c(sum(cnt[c("transpos","reverse","repeat","zinc")]), sum(cnt[c("receptor","defined prot")]),
#         cnt["undefined prot"], cnt["no prot"])

```

## Types of the component

```{r}


sv.graphcomp <- getGraphComponents(sv.new$edges)

sv.comp.member = sv.graphcomp$membership

s.tags = c("transpos","reverse","repeat","zinc", "receptor","defined prot", "undefined prot", 'no prot')
s.tags0 = rep('', length(s.tags))
s.tags0[1:4] = 'TE-like'
s.tags0[5:6] = 'Known Proteins'
s.tags0[7] = 'Undef. Proteins'
s.tags0[8] = 'No Proteins'
names(s.tags0) = s.tags

comp.tags = rep('', length(unique(sv.comp.member)))
for(s.tag in s.tags){
  tmp.tags = unique(sv.comp.member[sv.memb$name[sv.memb$prot == s.tag]])
  comp.tags[tmp.tags][comp.tags[tmp.tags] == ''] = s.tag
}

comp.tags[comp.tags == ''] = 'no prot'
sv.graphcomp$tag = comp.tags

comp.tags = data.frame(table(comp.tags))
colnames(comp.tags) = c('tag1', 'freq')
comp.tags$tag1 = factor(comp.tags$tag1, levels = s.tags)
comp.tags = comp.tags[order(comp.tags$tag1),]

comp.tags$tag0 = s.tags0[comp.tags$tag1]
comp.tags$tag0 = factor(comp.tags$tag0, levels = unique(s.tags0))

y.ticks = tapply(comp.tags$freq, comp.tags$tag0, sum)
y.ticks = y.ticks[!is.na(y.ticks)]

yy = sum(y.ticks) - cumsum(y.ticks) + y.ticks/2

comp.tags$ymin <- c(0, cumsum(comp.tags$freq)[-length(comp.tags$freq)])
comp.tags$ymax <- cumsum(comp.tags$freq)

x.step = rep(0, 8)
n.step = 10
x.step[c(5,7,8)] = n.step
x.step = cumsum(x.step)

comp.tags$ymin = comp.tags$ymin + x.step
comp.tags$ymax = comp.tags$ymax + x.step

y.min = tapply(comp.tags$ymin, comp.tags$tag0, min)
y.max = tapply(comp.tags$ymax, comp.tags$tag0, max)
y.val = (y.max + y.min) / 2
y.cnt = tapply(comp.tags$freq, comp.tags$tag0, sum)

df.text = data.frame(y.min = y.min, y.max = y.max, y.val = y.val, y.cnt = y.cnt, label = names(y.val))
df.text$angles <- 360 - (df.text$y.val / (max(comp.tags$ymax) + n.step)) * 360 
df.text$angles[2:3] = 180 + df.text$angles[2:3]

p = ggplot(comp.tags, aes(x = 0, y = freq, fill = tag1)) +
   geom_rect(aes(xmin = -0.5, xmax = 0.5, ymin = ymin, ymax = ymax)) +
   coord_polar("y", start = 0) +
   scale_fill_manual(values = g.cols) + ylim(0, max(comp.tags$ymax) + n.step) +
   theme_void() + xlim(-1.5, 0.7) + 
   geom_text(data=df.text, aes(x = 0.7, y = y.val, label = paste(label, y.cnt, sep = ': ')), 
             angle = df.text$angles, inherit.aes = FALSE) +
  theme(legend.position="none") + 
  annotate("text", x = -1.5, y = 0, label = paste('Total',sum(comp.tags$freq),'\n connected \ncomponents')) 

p
# 
# pdf(paste(path.figures, 'graph_new_pie_chart.pdf', sep = ''), width = 3.1, height = 3.1)
# print(p)     # Plot 1 --> in the first page of PDF
# dev.off()

```

## Non-arabidopsis
```{r}
x = readRDS(paste(path.work, 'sv_proteins_no_te_blast.rds', sep = ''))

x$org = substr(x$X3, 1, 3)

res = as.matrix(table(x$X1, x$org))

x$sv = paste(sapply(x$X1, function(s) strsplit(s, '\\|')[[1]][1]),
                    sapply(x$X1, function(s) strsplit(s, '\\|')[[1]][2]), sep = '|')
y = x[!duplicated(x$sv),]
rownames(y) = x$sv[!duplicated(x$sv)]

sv.graphcomp$org = y[names(sv.graphcomp$membership), 'org']

v = tapply(sv.graphcomp$org, sv.graphcomp$membership, function(x){
  
  x = x[!is.na(x)]
  
  if(length(x) == 0) return(NA)
  sum(x == 'Ara') / length(x)
  
} )

cl.non.ara = which((v <= 0.1) & (!is.na(v)))




table(sv.graphcomp$tag[cl.non.ara])

tmp = cl.non.ara[sv.graphcomp$tag[cl.non.ara] == 'transpos']

sv.graphcomp$csize[tmp]


# Which are not Arabidopsis
g.part %v% "org" = y[g.part.names, 'org'] != 'Ara'
set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "org",
            palette = 'Set1',
            # mode = "kamadakawai"
            )  + coord_fixed(ratio = 1)
p


# Which are not arabidopsis and TEs
g.part %v% "org" = sv.graphcomp$membership[g.part.names] %in% tmp
set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "org",
            palette = 'Set1',
            # mode = "kamadakawai"
            ) + coord_fixed(ratio = 1) 
p

cbind(tmp,sv.graphcomp$csize[tmp])


g.part %v% "org" = sv.graphcomp$membership[g.part.names] %in% 5
set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "org",
            palette = 'Set1',
            # mode = "kamadakawai"
            ) 
p



g.part %v% "org" = sv.graphcomp$membership[g.part.names] == 'SVgr_3_id_79231|5005'
set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "org",
            palette = 'Set1',
            # mode = "kamadakawai"
            ) 
p

```

# EDTA
```{r}

```


## INTERESTING
### no prot
```{r}
tag.interes = 'no prot'
# tag.interes = 'transpos'


s.tag.interes = gsub(' ', '_', tag.interes)


path.candidates = paste(path.work, 'candidates_',s.tag.interes,'/', sep = '')
if (!dir.exists(path.candidates)) {
  dir.create(path.candidates)
}

# names of SV in "no prot" category
cl.np.prot = which(sv.graphcomp$tag == tag.interes)
cl.np.prot = table(sv.graphcomp$membership[sv.graphcomp$membership %in% cl.np.prot])
cl.np.prot = as.numeric(names(cl.np.prot)[cl.np.prot >= 3]) 


len.all = c()
for(i.cl in cl.np.prot){
  
  message(i.cl)
  sv.cl.tmp = names(sv.graphcomp$membership[sv.graphcomp$membership == i.cl])
  lengths = as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2]))
  len.med = median(lengths)
  
  criteria = abs(lengths - len.med) < len.med*0.1
  if(sum(criteria) != 0){
    sv.cl.tmp = sv.cl.tmp[criteria]
  } else {
    d = as.matrix(dist(lengths, method = "euclidean"))
    indices <- which(d < len.med * 0.1, arr.ind = TRUE)
    tmp.graph <- igraph::make_graph(t(indices), directed = T)
    tmp.graph <- igraph::simplify(tmp.graph)
    tmp.comp <- igraph::components(tmp.graph)
    
    cl.big = which(tmp.comp$csize == max(tmp.comp$csize))[1]
    id.cl.tmp = which(tmp.comp$membership %in% cl.big)
    
    
    if(length(id.cl.tmp) != 0){
      sv.cl.tmp = sv.cl.tmp[id.cl.tmp]
    } else {
      sv.cl.tmp = sv.cl.tmp[lengths == min(lengths)]
    }
  }
  
  len.all = c(len.all,mean(as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2]))))
  print(as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2])))
  # next()
  
  seqs.tmp = sv.seqs[sv.cl.tmp]
  
  # Fix direction

  file.tmp = paste(path.candidates, 'sv_clust_', sprintf("%04d", i.cl), '.fasta', sep = '')
  if(length(seqs.tmp) > 1){
    seq1 = seq2nt(seqs.tmp[1])
    for(i in 2:length(seqs.tmp)){
      
      seq2 = seq2nt(seqs.tmp[i])
      
      dot.scores = dotScore(seq1, seq2)
      
      if(dot.scores[2] > dot.scores[1]){
        # stop('RC found')
        pokaz(1, i)
        seqs.tmp[i] = nt2seq(revCompl(seq2nt(seqs.tmp[i])))
        dotplot(seq1, seq2, 10, 9)
      }
    }
  }
  
  writeFastaMy(seqs.tmp, file.tmp)
}
```


### transpos
```{r}
# tag.interes = 'no prot'
tag.interes = 'transpos'
tag.interes = 'undefined prot'


s.tag.interes = gsub(' ', '_', tag.interes)


path.candidates = paste(path.work, 'candidates_',s.tag.interes,'/', sep = '')
if (!dir.exists(path.candidates)) {
  dir.create(path.candidates)
}

# names of SV in "no prot" category
cl.np.prot = which(sv.graphcomp$tag == tag.interes)
cl.np.prot.cnt = table(sv.graphcomp$membership[sv.graphcomp$membership %in% cl.np.prot])
cl.np.prot = as.numeric(names(cl.np.prot.cnt)[cl.np.prot.cnt > 3]) 

cl.np.prot.cnt[as.character(cl.np.prot)]


len.all = c()

for(i.cl in cl.np.prot){
  
  g.part %v% "cluster" = sv.graphcomp$membership[g.part.names] == i.cl
  set.seed(239)
  p <- ggnet2(g.part, label = F, edge.color = "black", 
              node.size = 1,
              color = "cluster",
              palette = 'Set2',
              # mode = "kamadakawai"
              ) 
  p
  
  pdf(paste(path.candidates, 'graph_sv_clust_', sprintf("%04d", i.cl), '.pdf', sep = ''), width = 5, height = 5)
  print(p + guides(color = F))     # Plot 1 --> in the first page of PDF
  dev.off()

}
```

### Specific component
```{r}
i.cl = 69
message(i.cl)
sv.cl.tmp = names(sv.graphcomp$membership[sv.graphcomp$membership == i.cl])
lengths = as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2]))
pokaz(lengths)
len.med = median(lengths)

seqs.tmp = sv.seqs[sv.cl.tmp]


i1 = 1
i2 = 5
s1 = seq2nt(seqs.tmp[i1])
s2 = seq2nt(seqs.tmp[i2])
p.dot = dotplot(s1, s2, 15, 13) + xlab(sv.cl.tmp[i1]) + ylab(sv.cl.tmp[i2])
p.dot


# ----  Plots ----
path.figures = paste(path.base, '02_analysis/04_sv/03_figures/', sep = '')
path.components = paste(path.figures, 'components_new/', sep = '')

# Plot Dotplot
pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.cl),'_dot_short.pdf', sep = ''), 
    width = 3, height = 3)
print(p.dot)   
dev.off()


# ORFs
res = orfFinder(nt2seq(seqs.tmp[i1]))

p.orf = orfplot(res$pos)
p.orf

pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.cl),'_orf.pdf', sep = ''), 
    width = 4, height = 3)
print(p.orf)   
dev.off()

# BLAST MY
path.components.data = paste(path.figures, 'components_new_data/', sep = '')
x = read.table(paste(path.components.data, 'comp_',i.cl,'_blast_my.txt', sep = ''), stringsAsFactors = F)

x$sp = sapply(x$V8, function(s) strsplit(s, '\\|')[[1]][1])
if(i.cl == 5){
  x = x[x$V1 != "SVgr_2_id_102135|5195:ORF|3446|3763|+|aaLEN|106",]  
} else {
  x = x[x$V1 %in% c("SVgr_1_id_100421|5252:ORF|2645|4804|+|aaLEN|720","SVgr_1_id_100421|5252:ORF|431|2455|+|aaLEN|675" ),]
  
}

x$shape = as.factor(as.numeric(as.factor(x$sp)) %% 4)

shapes <- c("brap_v3_01"=1  ,   "sweet_orange" =2,    "hibiscus" =3,        "acer_negundo" =4,    "aly_MN47"   =16,
            "asu_ASM1920280v1" =17, "atal_0" =18     , 'potato'= 15, 'microthlaspi' = 19)

p = ggplot(x, aes(x = V6, y = V7, color = sp, shape = sp)) +
  geom_point() +
  # geom_point(alpha = 0.1) +
  # facet_wrap(~ V1, scales = "free") +
  facet_grid(rows = vars(sp), cols = vars(V1)) +
  theme_minimal() + xlab('Identity') + ylab('Coverage') +
   scale_color_viridis(discrete = TRUE) +
  scale_shape_manual(values = shapes) +  # Применяем определенные формы
  theme(strip.text.x = element_text(size = 6), strip.background = element_blank())

p
pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.cl),'_blast.pdf', sep = ''), 
    width = 5, height = 8)
print(p)   
dev.off()

```


```{r}
criteria = abs(lengths - len.med) < len.med*0.1
  if(sum(criteria) != 0){
    sv.cl.tmp = sv.cl.tmp[criteria]
  } else {
    d = as.matrix(dist(lengths, method = "euclidean"))
    indices <- which(d < len.med * 0.1, arr.ind = TRUE)
    tmp.graph <- igraph::make_graph(t(indices), directed = T)
    tmp.graph <- igraph::simplify(tmp.graph)
    tmp.comp <- igraph::components(tmp.graph)
    
    cl.big = which(tmp.comp$csize == max(tmp.comp$csize))[1]
    id.cl.tmp = which(tmp.comp$membership %in% cl.big)
    
    
    if(length(id.cl.tmp) != 0){
      sv.cl.tmp = sv.cl.tmp[id.cl.tmp]
    } else {
      sv.cl.tmp = sv.cl.tmp[lengths == min(lengths)]
    }
  }
  
  len.all = c(len.all,mean(as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2]))))
  print(as.numeric(sapply(sv.cl.tmp, function(s) strsplit(s, '\\|')[[1]][2])))
  # next()
  
  seqs.tmp = sv.seqs[sv.cl.tmp]
  
  # Fix direction

  file.tmp = paste(path.candidates, 'sv_clust_', sprintf("%04d", i.cl), '.fasta', sep = '')
  if(length(seqs.tmp) > 1){
    seq1 = seq2nt(seqs.tmp[1])
    for(i in 2:length(seqs.tmp)){
      
      seq2 = seq2nt(seqs.tmp[i])
      
      dot.scores = dotScore(seq1, seq2)
      
      if(dot.scores[2] > dot.scores[1]){
        # stop('RC found')
        pokaz(1, i)
        seqs.tmp[i] = nt2seq(revCompl(seq2nt(seqs.tmp[i])))
        dotplot(seq1, seq2, 10, 9)
      }
    }
  }
  
  writeFastaMy(seqs.tmp, file.tmp)


```



```{r}





s1 = seq2nt(sv.seqs[sv.cl.tmp[1]])
s2 = seq2nt(sv.seqs[sv.cl.tmp[4]])
p.dot = dotplot(s1, s2, 15, 9)
p.dot

pdf(paste(path.candidates, 'dot_sv_clust_', sprintf("%04d", i.cl), '.pdf', sep = ''), width = 4, height = 4)
print(p.dot)     # Plot 1 --> in the first page of PDF
dev.off()



```



## No-prot examples
```{r}



cl.np.prot = which(sv.graphcomp$tag == 'no prot')
cl.np.prot = table(sv.graphcomp$membership[sv.graphcomp$membership %in% cl.np.prot])
cl.np.prot = as.numeric(names(cl.np.prot)[cl.np.prot > 2])

cl.np.prot

p.list = list()
seq.list = c()
for(i.com in cl.np.prot){
  pokaz(i.com)
  names.com.sv = names(sv.graphcomp$membership[sv.graphcomp$membership == i.com])
  names.len = as.numeric(sapply(names.com.sv, function(s) tail(strsplit(s, '\\|')[[1]], 1)))
  print(names.len)
  
  s = sv.seqs[[names.com.sv[1]]]
  ns = length(s)
  if(!((ns >= 200) & (ns <= 400))) next
  # stop()
  
  p = dotplot(s, s, 15, 9)
  p.list[[length(p.list) + 1]] = p
  seq.list[paste('id', i.com, sep = '_')] = nt2seq(s)
}

library(gridExtra)
do.call(grid.arrange, p.list)

```




## Examples
```{r}


sv.memb$len <- as.numeric(sapply(sv.memb$name, function(s) strsplit(s, '\\|')[[1]][2]))
rownames(sv.se) = sv.se$name
sv.memb$freq = sv.se[sv.memb$name,]$freq.max
sv.memb$indel = sv.se[sv.memb$name,]$sin

# Define indel type
n.cutoff = 3
n = 28
sv.memb$sin = 'M'
sv.memb$sin[sv.memb$freq >= (n - n.cutoff)] = 'D'
sv.memb$sin[sv.memb$freq <= n.cutoff] = 'I'


path.components = paste(path.figures, 'components_new/', sep = '')
if (!dir.exists(path.components)) {
  dir.create(path.components)
}

sv.new.comp <- getGraphComponents(sv.new$edges)
comp.target = which(sv.new.comp$csize >= 5)

for(i.target in comp.target){
# for(i.target in comp.target[1]){

  # Visualise one component
  
  sub.names = names(sv.new.comp$membership)[sv.new.comp$membership == i.target]
  b.graph.sub = sv.new$edges[(sv.new$edges[,1] %in% sub.names) | 
                                 (sv.new$edges[,2] %in% sub.names),,drop=F]
  
  g.sub <- network(b.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
  g.sub.names = network.vertex.names(g.sub)
  
  
  set.seed(20)
  p.te <- ggnet2(g.sub, 
                 label = sv.memb[g.sub.names,]$len, 
                 edge.color = "black", 
              # node.size = sv.graph$nodes.traits[g.sub.names,]$cnt,
              node.size = 12,
              color =  sv.memb[g.sub.names,]$prot,
              mode = 'kamadakawai',
               arrow.gap = 0.08, arrow.size = 3,
              palette = g.cols) +
    guides(size = F) +
    # theme_minimal() + ylab(NULL) + xlab('Number: freq of presence') +
      theme(legend.key.size = unit(0.5, "cm"))  +
      guides(color = guide_legend(ncol = 2 )) + 
                   theme(legend.position = "bottom")
      
  

    set.seed(20)
  p.freq <- ggnet2(g.sub, 
                 label = sv.memb[g.sub.names,]$freq, 
                 label.color = 'white',
                 label.size = 3,
                 edge.color = "grey20", 
              # node.size = sv.graph$nodes.traits[g.sub.names,]$cnt, 
              node.size = 7,
              color = indel.new.names[sv.memb[g.sub.names,]$sin],
              mode = 'kamadakawai',
              arrow.gap = 0.04, arrow.size = 3,
              palette = indel.pallete
              ) +
    guides(size = F) +
    # theme_minimal() + ylab(NULL) + xlab('Number: freq of presence') +
      theme(legend.key.size = unit(0.5, "cm"))  +
      guides(color = guide_legend(ncol = 2 )) + 
                   theme(legend.position = "bottom")
  
  
  pp = invisible(ggarrange(p.te+ annotate("text", x = -Inf, y = Inf, 
                                           label = i.target, hjust = 0, vjust = 1),
                 p.freq,
                 
                 nrow=1))
  
  # pp
  
  # TODO: third plot - frequency plot (three of colors: insertion, deletion, indel)
  
  pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'.pdf', sep = ''), 
      width = 8, height = 4)
  print(pp)     # Plot 1 --> in the first page of PDF

  dev.off()

}



```


### Get sequences and align
```{r}


path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
  dir.create(path.mafft)
}


comp.target = 2
sv.name.target = names(sv.new.comp$membership)[sv.new.comp$membership == comp.target]
sv.name.target = sv.name.target[order(-sv.memb[sv.name.target,]$len)]

seqs.target = sv.seqs[sv.name.target]
sv.name.target = names(seqs.target)

# Find orientations of sequences

bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'

# TODO: define the first orientation by the longest ORF

dir.seq = c('-', '+')

for(i in 1:(length(orientation.target) - 1)){
  bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
  bl.tmp = bl.tmp[order(-bl.tmp$V7),]
  bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
  bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
  bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
  if(nrow(bl.tmp) == 0) next
  
  if(orientation.target[i] == '+'){
    orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
  }
  
  if(orientation.target[i] == '-'){
    orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
  }
  
  if(sum(orientation.target == '.') == 0) break
}
# 
for(i in which(orientation.target == '-')){
  seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}

seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)

# alignment <- msa(seqs.target.msa)

# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)

system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))

alignment = readDNAStringSet(aln.fasta)

seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)

p.msa

rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max


pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''), 
    width = 6, height = 4)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()

```

#### Separate examples
```{r}

i.target = 2
sub.names = names(sv.new.comp$membership)[sv.new.comp$membership == i.target]

i.sv = 1
message(sub.names[i.sv])
seq = sv.seqs[[sub.names[i.sv]]]

dotplot(seq, seq, 15, 13)
dotplot(seq, seq, 15, 10)


nt2seq(seq)
```


```{r}

seq1 <- as.character(seqs.target.msa[4])
seq1 <- unlist(strsplit(seq1, NULL))
names(seq1) = NULL

dotplot(seq1, 
        seq1, 
        wsize = 15, nmatch = 13)
```


#### I don't know (EDTA)
```{r}
sv.se$freq = sv.se$freq.max
n.cutoff = 3
n = 28
sv.se$sin = 'indel'
sv.se$sin[sv.se$freq >= (n - n.cutoff)] = 'deletion'
sv.se$sin[sv.se$freq <= n.cutoff] = 'insertion'


g.nodes.prot.sin = g.nodes.prot
g.nodes.prot.sin[names(g.nodes.prot.sin) %in% sv.se$name[sv.se$sin != 'insertion'] ] = 'na'
g.cols['na'] = 'white'




set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            # node.size = g.nodes.cnt[b.graph.names], 
            node.size = 1,
            color = g.nodes.prot.sin[b.graph.names],
            palette = g.cols,
            # mode = "kamadakawai"
            ) + guides(size = F)
p 

# 
# path.figures  = '/Volumes/Samsung_T5/vienn/work_te/'
# pdf(paste(path.figures, 'graph_sv_note_insertion.pdf', sep = ''), width = 6, height = 4)
# print(p)     # Plot 1 --> in the first page of PDF
# dev.off()


alpha.edta = rep(1, length(b.graph.names))
names(alpha.edta) = b.graph.names

sv.annot.adta = rowSums(sv.annot[,11:ncol(sv.annot)] > 0.7) > 0
sv.annot.adta = sv.annot.adta[sv.se$gr]
names(sv.annot.adta) = sv.se$name
sv.annot.adta = sv.annot.adta[sv.annot.adta]
alpha.edta[names(alpha.edta) %in% names(sv.annot.adta)] = 0


set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            # node.size = g.nodes.cnt[b.graph.names], 
            node.size = 1,
            alpha=1-alpha.edta,
            color = g.nodes.prot[b.graph.names],
            palette = g.cols,
            # mode = "kamadakawai"
            ) + guides(size = F)
p 


pdf(paste(path.figures, 'graph_mob_note_edta.pdf', sep = ''), width = 6, height = 4)
print(p)     # Plot 1 --> in the first page of PDF
dev.off()

path.figures  = '/Volumes/Samsung_T5/vienn/work_te/'
pdf(paste(path.figures, 'graph_mob_note_edta_no_legend.pdf', sep = ''), width = 5, height = 5)
print(p+ theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()

```


## UFO sequences

```{r}
comp.ufo.id = which(sv.graphcomp$tag == "no prot")

comp.ufo.id = comp.ufo.id[sv.graphcomp$csize[comp.ufo.id] >= 5]

sv.ufo.memb = c()
for(i.ufo in comp.ufo.id){
  sv.tmp = names(sv.graphcomp$membership)[sv.graphcomp$membership == i.ufo]
  pokaz('-------')
  print(sv.tmp)
  sv.ufo.memb = c(sv.ufo.memb, sv.tmp[1])
}

sv.ufo.seq = sv.seqs[sv.ufo.memb]

writeFastaMy(sv.ufo.seq, paste(path.work, 'ufo.fasta', sep = ''))


```

### dotplots
```{r}

path.components.ufo = paste(path.figures, 'components_ufo/', sep = '')
if (!dir.exists(path.components.ufo)) {
  dir.create(path.components.ufo)
}

for(i.ufo in comp.ufo.id){
  sv.tmp = names(sv.graphcomp$membership)[sv.graphcomp$membership == i.ufo]
  sv1 = sv.tmp[1]
  p1 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 12) 
  
  p2 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 11)
  
  p3 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 10)
  
  p4 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 9)
  
  p5 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 8)
  
  p6 = dotplot(seq2nt(sv.seqs[sv1]),
              seq2nt(sv.seqs[sv1]), 
              15, 8)
  

  pp.ufo.dot = invisible(ggarrange(p1, p2, p3, p4, p5, p6,
                                  nrow = 2, ncol = 3))
  
  
  pdf(paste(path.components.ufo, 
        'ufo_comp_', i.ufo,'_dot.pdf', sep = ''), 
  width = 8, height = 6)
  print(pp.ufo.dot)
  dev.off()


}





```


### GC content
```{r}
nts = c('A', 'T', 'G', 'C')
gc.content = c()
for(i.ufo in comp.ufo.id){
  sv.tmp = names(sv.graphcomp$membership)[sv.graphcomp$membership == i.ufo]
  sv1 = sv.tmp[1]
  s.tmp = toupper(seq2nt(sv.seqs[sv1]))
  table(s.tmp)
  gc = c()
  for(s.nt in nts){
    gc = c(gc, sum(s.tmp == s.nt))
  }
  names(gc) = nts
  print(gc / sum(gc))
}

```


## Plot with component ID
```{r}


tmp.graph <- igraph::make_graph(t(sv.edges), directed = T)
tmp.graph <- igraph::simplify(tmp.graph)
tmp.comp <- igraph::components(tmp.graph)

size.limit = 5
comp.id = as.character(tmp.comp$membership)
names(comp.id) = names(tmp.comp$membership)
comp.id[tmp.comp$csize[tmp.comp$membership] < size.limit] = ''

names.te = names(g.nodes.prot)[g.nodes.prot %in% c('transpos', 'reverse')]

comp.id[!(names(comp.id) %in% names.te)] = ''

comp.id[duplicated(comp.id)] = ''


comp.remain = as.numeric(comp.id[comp.id != ''])
alpha = rep(0, length(b.graph.names))
names(alpha) = names(tmp.comp$membership)
alpha[tmp.comp$membership %in% comp.remain] = 1

set.seed(239)
p <- ggnet2(g.part, label = comp.id[b.graph.names], 
            label.color = "black",
            label.size = 3,
            edge.color = "grey", 
            alpha = alpha[b.graph.names],
            # node.size = g.nodes.cnt[b.graph.names], 
            node.size = 1,
            color = g.nodes.prot[b.graph.names],
            palette = g.cols,
            # mode = "kamadakawai"
            ) + guides(size = F)
p 


path.figures  = '/Volumes/Samsung_T5/vienn/work_te/'
pdf(paste(path.figures, 'graph_sv_note_numbers.pdf', sep = ''), width = 5, height = 5)
print(p + theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
dev.off()



# Order of components
cnt = table(tmp.comp$membership[tmp.comp$membership %in% comp.remain])
cnt = cnt[order(-cnt)]

```

## CNV
```{r}

cnv = readRDS('/Volumes/Samsung_T5/vienn/work_sv/similar_cnv_sv_on_accessions_cum_0.9.rds')

```

## Plot one specific network
```{r}

path.figures.examples  = '/Volumes/Samsung_T5/vienn/work_te/examples/'

# 
# tmp.graph <- igraph::make_graph(t(sv.edges), directed = T)
# tmp.graph <- igraph::simplify(tmp.graph)
# tmp.comp <- igraph::components(tmp.graph)
# 
# tmp.cnt = table(tmp.comp$membership)
# tmp.cnt = -sort(-tmp.cnt)

tmp.cnt = cnt

for(k in 1:length(tmp.cnt)){
  tmp.k = as.numeric(names(tmp.cnt)[k])
  tmp.names = names(tmp.comp$membership)[tmp.comp$membership == tmp.k]
  b.graph.sub = sv.edges[(sv.edges[,1] %in% tmp.names) & 
                          (sv.edges[,2] %in% tmp.names),]
  
  
  g.part.sub <- network(b.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
  b.graph.names.sub = network.vertex.names(g.part.sub)
  
  
    
  b.graph.size.sub <- as.numeric(sub(".*\\|", "", b.graph.names.sub))
  names(b.graph.size.sub) = b.graph.names.sub
  # b.graph.size.sub = ceiling(log(b.graph.size.sub, 10))
  
  if((length(unique( g.nodes.prot[b.graph.names.sub])) == 1)){
    set.seed(20)
    p <- ggnet2(g.part.sub, label = b.graph.size.sub[b.graph.names.sub], edge.color = "black", 
                node.size = 15,
                arrow.gap = 0.07, arrow.size = 3,
                color = g.cols[g.nodes.prot[b.graph.names.sub][1]],
                ) + guides(size = F) +  ggtitle(paste('Component #', tmp.k))
    p
  } else {
    set.seed(20)
    p <- ggnet2(g.part.sub, label = b.graph.size.sub[b.graph.names.sub], edge.color = "black", 
                node.size = 15,
                arrow.gap = 0.07, arrow.size = 3,
                color = g.nodes.prot[b.graph.names.sub],
                palette = g.cols,
                ) + guides(size = F) +  ggtitle(paste('Component #', tmp.k))
    p
  }
  
 
  
  pdf(paste(path.figures.examples, 'graph_sv_example_',k,'_comp_',tmp.k,'.pdf', sep = ''), width = 5, height = 4)
  print(p + theme(legend.position = "none"))     # Plot 1 --> in the first page of PDF
  dev.off()
  
  # annotation
  annot.tmp = sv.prot[sv.prot$name %in% b.graph.names.sub,]
  # annot.tmp = annot.tmp[annot.tmp$transpos == 1,]
  
  write.table(annot.tmp, paste(path.figures.examples, 'graph_sv_example_',k,'_pblast.txt', sep = ''), 
              row.names = F, col.names = F, quote = F, sep = '\t')
  
  
  # if EDTA annotation exists
  sv.tmp = unique(c(b.graph.sub))
  sv.tmp.cut <- gsub("\\|.*", "", sv.tmp)
  sv.annot.tmp = sv.annot[sv.tmp.cut,]
  n.fix = 9
  sv.annot.tmp  = sv.annot.tmp[,c(1:n.fix,n.fix+which(colSums(sv.annot.tmp[,(n.fix+1):ncol(sv.annot.tmp)]) != 0))]
  rownames(sv.annot.tmp) = sv.tmp
    
  write.table(sv.annot.tmp, paste(path.figures.examples, 'graph_sv_example_',k,'_edta.txt', sep = ''), 
             row.names = F, quote = F, sep = '\t')
  
  # Copy0Number variation
  cnv.tmp = cnv[sv.tmp,]
  
  heatmap(cnv.tmp, col = colorRampPalette(c("white", "red"))(20))
  
}

```



# METHYLATION


## Methylation
```{r}

path.methylation = paste(path.base, 
                         '01_data/06_methylation/001.bsseq_on_pacbio/003.pacbiov2.1_Based/', 
                         sep = '')
path.meth.only = paste(path.base, 
                       '01_data/06_methylation/001.bsseq_on_pacbio/003.pacbiov2.1_Based/methylation_only/', 
                       sep = '')


files.meth = list.files(path.methylation, pattern = "\\.tsv$")
acc.meth = sapply(files.meth, function(s) strsplit(strsplit(s, '_')[[1]][2], '\\.')[[1]][1])

sv.pos.bin.long = sv.pos.bin[sv.se$len >= 100,]
rownames(sv.se) = sv.se$gr

sv.se.pres = matrix(0, nrow = nrow(sv.pos.bin.long), ncol = length(acc.meth), 
                    dimnames = list(rownames(sv.pos.bin.long), acc.meth))
sv.se.meth = matrix(0, nrow = nrow(sv.pos.bin.long), ncol = length(acc.meth), 
                    dimnames = list(rownames(sv.pos.bin.long), acc.meth))

for(acc in acc.meth){
  pokaz('Accession', acc)
  sv.pos.bin.acc = sv.pos.bin.long[, acc, drop = F]
  sv.pos.bin.acc = sv.pos.bin.acc[sv.pos.bin.acc != 0, ,drop = F]
  
  meth.file = names(acc.meth)[acc.meth == acc]
  file.meth.only = paste(path.meth.only, gsub('.tsv', '.1only.rds', meth.file), sep = '')
  if(!file.exists(file.meth.only)){
    
    pokaz('Create meth-only files')
    meth.value = read.table(paste(path.methylation, meth.file, sep = ''), stringsAsFactors = F)
    meth.value = meth.value[meth.value$V7 == 1,]
    dim(meth.value)  
    saveRDS(meth.value, file.meth.only)
  } else {
    pokaz('Read meth-only files')
    meth.value = readRDS(file.meth.only)
  }
  
  pos.beg.acc = sv.pos.beg[rownames(sv.pos.bin.acc), acc]
  pos.end.acc = sv.pos.end[rownames(sv.pos.bin.acc), acc]
  
  idx.remain = (pos.beg.acc != 0) & (pos.end.acc != 0)
  pokaz('Removed zeros', sum(!idx.remain))
  sv.pos.bin.acc = sv.pos.bin.acc[idx.remain,,drop = F]
  pos.beg.acc = pos.beg.acc[idx.remain]
  pos.end.acc = pos.end.acc[idx.remain]
  
  sv.se.pres[rownames(sv.pos.bin.acc), acc] = 1
  
  
  meth.value$type = 'CHH'
  meth.value$type[meth.value$V4 %in% c('CGA', 'CGC', 'CGG', 'CGT')] = 'CG'
  meth.value$type[meth.value$V4 %in% c('CAG', 'CCG', 'CTG')] = 'CHG'
  
  
  len.max = max(max(pos.beg.acc), max(pos.end.acc), meth.value$V2[nrow(meth.value)])
  
  
  df.meth = data.frame(matrix(0, nrow = length(pos.beg.acc), ncol = 3,
                       dimnames = list(rownames(sv.pos.bin.acc), c('CG', 'CHG', 'CHH'))))
  for(meth.type in colnames(df.meth)){
    
    pos.meth = rep(0, len.max + 100000)
    pos.meth[meth.value$V2[meth.value$type == meth.type]] = 1
    pokaz('Methilation', meth.type, 'amount:', sum(pos.meth))
    
    for(irow in (1:nrow(df.meth))){
      df.meth[irow, meth.type] = sum(pos.meth[pos.beg.acc[irow]:pos.end.acc[irow]])
    }
    
  }
  
  # df.meth.relative = rowSums(df.meth) / sv.se[rownames(sv.pos.bin.acc),]$len
  df.meth.relative = rowSums(df.meth) #/ sv.gc[rownames(sv.pos.bin.acc)]
  
  sv.se.meth[rownames(sv.pos.bin.acc), acc] = df.meth.relative
  
}

head(sv.se.meth)
# Divide to GC

dim(sv.se.meth)

for(icol in 1:ncol(sv.se.meth)){
  tmp = sv.se.meth[,icol] / sv.gc[rownames(sv.se.meth)] 
  tmp[sv.gc[rownames(sv.se.meth)] == 0] = 0
  tmp[tmp > 1] = 0  
  if(sum(is.na(tmp)) > 0) stop('NA methylation found')
  sv.se.meth[, icol] = tmp
}


sv.se.meth.max = rowMax(sv.se.meth)

sv.se.meth.max.my = sv.se.meth.max


# 
```

## Alexandra
```{r}
meth.types = c('CHH', 'CHG', 'CG')

sv.se.meth.max.all = list()
sv.se.meth.mean.all = list()

for(meth.type in meth.types){
  x = read.table(paste('/Volumes/Samsung_T5/vienn/00_paper/01_data/06_methylation/02_on_sv_v03/',
                       meth.type,
                       '.methylation_level.12accessions.svs_v03.txt', sep = ''), 
                 header = 1, row.names = 1, check.names = F)
  
  x = x[rowSums(!is.na(x)) != 0,]
  x[is.na(x)] = 0
  
  common.names = intersect(rownames(x), rownames(sv.pos.bin))
  x.bin = sv.pos.bin[common.names,colnames(x)]
  x = x[common.names,]
  
  x[is.na(x)] = 0
  
  x[x.bin == 0] = NA
  
  sv.se.meth.max.all[[meth.type]] = rowMax(x)  
  sv.se.meth.mean.all[[meth.type]] = rowMeans(x, na.rm = T)  
  
}


# Read Chip-seq



x = read.table(paste('/Volumes/Samsung_T5/vienn/00_paper/01_data/06_methylation/02_on_sv_v03/',
                       'ChIPseq_coverage.input_and_quantile_normalized.6accessions.svs_v03.txt', sep = ''), 
                 header = 1, check.names = F)
rownames(x) = x$gene
x = x[,-ncol(x)]

x.chip.type = sapply(colnames(x), function(s) strsplit(s, '\\.')[[1]][1] )
x.acc = sapply(colnames(x), function(s) strsplit(s, '\\.')[[1]][2] )
chip.type = unique(x.chip.type)
for(c.type in chip.type){
  pokaz(c.type)
  idx.type = x.chip.type == c.type
  y = x[,idx.type]
  colnames(y) = x.acc[idx.type]
  
  y = y[rowSums(!is.na(y)) != 0,]
  y[is.na(y)] = 0
  
  common.names = intersect(rownames(y), rownames(sv.pos.bin))
  y.bin = sv.pos.bin[common.names,colnames(y)]
  y = y[common.names,]
  
  y[is.na(y)] = 0
  
  y[y.bin == 0] = NA
  
  sv.se.meth.max.all[[c.type]] = rowMax(y)  
  sv.se.meth.mean.all[[c.type]] = rowMeans(y, na.rm = T)    
  
  y.names = paste(c.type, '_acc_', colnames(y), sep = '')
  for(i.col in 1:ncol(y)){
    pokaz(y.names[i.col])
    tmp = y[,i.col]
    names(tmp) = rownames(y)
    sv.se.meth.max.all[[y.names[i.col]]] = tmp
    sv.se.meth.mean.all[[y.names[i.col]]] = tmp
  }

}


```

### Compare with my
```{r}
common.name = intersect(names(sv.se.meth.max.my), names(sv.se.meth.max))

plot(sv.se.meth.max.my[common.name], sv.se.meth.max[common.name])


table(sv.se.meth.max.my[common.name] > 0, sv.se.meth.max[common.name] > 0)


which((sv.se.meth.max.my[common.name] == 0) & (sv.se.meth.max[common.name] > 0))


sv.pos.beg['SVgr_1_id_7213',]
sv.pos.end['SVgr_1_id_7213',]

d = sv.pos.end['SVgr_1_id_8842', colnames(x)] - sv.pos.beg['SVgr_1_id_8842',colnames(x)]
d

```




## Meth: violineplot
```{r}

min.len = 1000
# for(meth.type in names(sv.se.meth.mean.all)){
for(meth.type in names(sv.se.meth.mean.all)[1:3]){
  
  # for(s.stat in c('mean', 'max')){
  for(s.stat in c('max')){
    
    pokaz(meth.type, s.stat)
      
    if(s.stat == 'mean'){
      meth.tmp = sv.se.meth.mean.all[[meth.type]]
    } else {
      meth.tmp = sv.se.meth.max.all[[meth.type]]
    }
      
    path.figures.meth = paste(path.figures, 'meth_express/', sep = '')
    sv.se$meth = meth.tmp[sv.se$gr]
    
    sv.se$te = factor(sv.se$te, levels = names(te.cols))
    
    g = ggplot(sv.se[(sv.se$len > min.len) & !(is.na(sv.se$meth)),], aes(x = te, y = meth, fill = te)) +
      geom_violin(draw_quantiles = c(0.5), scale = "width", width = 0.6) +
      # ylim(0, 25000) +
        scale_fill_manual(values=te.cols, name ='TE content', 
                        labels = c('none', 'is complete', 'is fragment', 
                                   'contains complete', 'contains fragment')
                        ) +
      xlab(NULL) + 
      # xlab('TE content') + 
      ylab(paste(meth.type, 'methylation', sep = ' ')) +
      # scale_y_log10() + 
      geom_jitter(width = 0.2, size = 1, alpha = 0.07, stroke = 0) +
      theme_minimal() +
      guides(fill = FALSE) + theme(legend.position = "none") +
      scale_x_discrete(labels = c('none', 'is complete',
                                   'contains complete', 'contains fragment', 'is fragment')) +
      theme(axis.text.x = element_text(angle = 30, hjust = 1))
    
    g
    
    
    pdf(paste(path.figures.meth, 'meth_',meth.type, '_in_te_type_',s.stat,'_',min.len,'.pdf', sep = ''), 
        width = 5, height = 3.5)
    print(g )     # Plot 1 --> in the first page of PDF
    dev.off()
  
  }
  
}


```

```{r}
x <- rnorm(100) 

bins_fixed <- cut(x, breaks = c(-Inf, -1, 0, 1, Inf))
bins_fixed
```




### + frequency
```{r}
freq.bins = c(-Inf,1, 3, 24, Inf)
sv.se$freq.gr = cut(sv.se$freq.max, freq.bins,
                    labels = c('privat', 'low', 'mid', 'high'))

min.len = 1000
# for(meth.type in names(sv.se.meth.mean.all)){
for(meth.type in names(sv.se.meth.mean.all)[1:3]){
  
  # for(s.stat in c('mean', 'max')){
  for(s.stat in c('max')){
    
    pokaz(meth.type, s.stat)
      
    if(s.stat == 'mean'){
      meth.tmp = sv.se.meth.mean.all[[meth.type]]
    } else {
      meth.tmp = sv.se.meth.max.all[[meth.type]]
    }
      
    path.figures.meth = paste(path.figures, 'meth_express/', sep = '')
    sv.se$meth = meth.tmp[sv.se$gr]
    
    sv.se$te = factor(sv.se$te, levels = names(te.cols))
    
    # g = ggplot(sv.se[(sv.se$len > min.len) & !(is.na(sv.se$meth)),], 
    #            aes(x = interaction(freq.gr, te, sep = " - "), y = meth, fill = te)) +
    #   geom_boxplot(draw_quantiles = c(0.5), outliers = FALSE) +
    #   # geom_violin(draw_quantiles = c(0.5), scale = "width", width = 0.6) +
    #   # ylim(0, 25000) +
    #     scale_fill_manual(values=te.cols, name ='TE content', 
    #                     labels = c('none', 'is complete', 'is fragment', 
    #                                'contains complete', 'contains fragment')
    #                     ) +
    #   xlab('TE content') + ylab(paste(meth.type, 'methylation', sep = ' ')) +
    #   # scale_y_log10() + 
    #   geom_jitter(width = 0.2, size = 1, alpha = 0.1, stroke = 0) +
    #   theme_minimal() +
    #   guides(fill = FALSE) + theme(legend.position = "none") +
    #   # scale_x_discrete(labels = c('none', 'is complete', 'is fragment', 
    #   #                              'contains complete', 'contains fragment')) +
    #   theme(axis.text.x = element_text(angle = 30, hjust = 1))
    # 
    # g
    
    
      g = ggplot(sv.se[(sv.se$len > min.len) & !(is.na(sv.se$meth)),], 
               aes(x = freq.gr, y = meth, fill = te)) +
      geom_boxplot(draw_quantiles = c(0.5), outliers = FALSE) +
      # geom_violin(draw_quantiles = c(0.5), scale = "width", width = 0.6) +
      # ylim(0, 25000) +
        scale_fill_manual(values=te.cols, name ='TE content', 
                        labels = c('none', 'is complete', 'is fragment', 
                                   'contains complete', 'contains fragment')
                        ) +
      xlab('Frequency') + ylab(paste(meth.type, 'methylation', sep = ' ')) +
      # scale_y_log10() + 
      geom_jitter(width = 0.2, size = 1, alpha = 0.1, stroke = 0) +
      theme_minimal() +
      guides(fill = FALSE) + theme(legend.position = "none") +
      # scale_x_discrete(labels = c('none', 'is complete', 'is fragment', 
      #                              'contains complete', 'contains fragment')) +
        facet_grid(cols = vars(te),
                   labeller = as_labeller(c('noTE' = 'none', 
                                            'isTE' = 'is complete', 
                                            'isTEpart' = 'is fragment', 
                                            'hasTE' = 'contains compl.', 
                                            'hasTEpart' = 'contains frag.'))) +
      theme(axis.text.x = element_text(angle = 30, hjust = 1)) +
        theme(strip.text.x = element_blank())
    
    g
    
    
    
    pdf(paste(path.figures.meth, 'meth_',meth.type, '_in_te_type_',s.stat,'_',min.len,'_freq.pdf', sep = ''), 
        width = 5, height = 3.5)
    print(g )     # Plot 1 --> in the first page of PDF
    dev.off()
  
  }
  
}

```



### + in graph
```{r}


min.len = 1000
# for(meth.type in names(sv.se.meth.mean.all)){
for(meth.type in names(sv.se.meth.mean.all)[1:3]){
  
  # for(s.stat in c('mean', 'max')){
  for(s.stat in c('max')){
    
    pokaz(meth.type, s.stat)
      
    if(s.stat == 'mean'){
      meth.tmp = sv.se.meth.mean.all[[meth.type]]
    } else {
      meth.tmp = sv.se.meth.max.all[[meth.type]]
    }
      
    path.figures.meth = paste(path.figures, 'meth_express/', sep = '')
    sv.se.len$meth = meth.tmp[sv.se.len$gr]
    
    sv.se.len$te = factor(sv.se.len$te, levels = names(te.cols))
    
    g = ggplot(sv.se.len[(sv.se.len$len > min.len) & !(is.na(sv.se.len$meth)),], 
               aes(x = in.connect, y = meth, fill = te)) +
      geom_boxplot(draw_quantiles = c(0.5), outliers = FALSE) +
      # geom_violin(draw_quantiles = c(0.5), scale = "width", width = 0.6) +
      # ylim(0, 25000) +
        scale_fill_manual(values=te.cols, name ='TE content', 
                        labels = c('none', 'is complete', 'is fragment', 
                                   'contains complete', 'contains fragment')
                        ) +
      xlab('In Graph') + ylab(paste(meth.type, 'methylation', sep = ' ')) +
      # scale_y_log10() + 
      geom_jitter(width = 0.2, size = 1, alpha = 0.1, stroke = 0) +
      theme_minimal() +
      guides(fill = FALSE) + theme(legend.position = "none") +
      scale_x_discrete(labels = c('No', 'Yes')) +
      facet_grid(cols = vars(te),
                   labeller = as_labeller(c('noTE' = 'none', 
                                            'isTE' = 'is complete', 
                                            'isTEpart' = 'is fragment', 
                                            'hasTE' = 'contains compl.', 
                                            'hasTEpart' = 'contains frag.'))) +
      theme(axis.text.x = element_text(angle = 30, hjust = 1)) +
        theme(strip.text.x = element_blank()) + 
      stat_compare_means(aes(group = in.connect), label = "p.signif", method = "wilcox.test")
    
    g
    
    
    pdf(paste(path.figures.meth, 'meth_',meth.type, '_in_te_type_',s.stat,'_',min.len,'_in_graph.pdf', sep = ''), 
        width = 5, height = 3.5)
    print(g )     # Plot 1 --> in the first page of PDF
    dev.off()
  
  }
  
}
```



```{r}

min.len = 1000
for(meth.type in names(sv.se.meth.mean.all)){
  
  # for(s.stat in c('mean', 'max')){
  for(s.stat in c('max')){
    
    pokaz(meth.type, s.stat)
      
    if(s.stat == 'mean'){
      meth.tmp = sv.se.meth.mean.all[[meth.type]]
    } else {
      meth.tmp = sv.se.meth.max.all[[meth.type]]
    }
      
    path.figures.meth = paste(path.figures, 'meth_express/', sep = '')
    sv.se.len$meth = meth.tmp[sv.se.len$gr]
    
    sv.se.len$te = factor(sv.se.len$te, levels = names(te.cols))
    
    g = ggplot(sv.se.len[(sv.se.len$len > min.len) & !(is.na(sv.se.len$meth)),], 
               aes(x = interaction(freq.gr, in.connect, te, sep = " - "), y = meth, fill = te, alpha = in.connect)) +
      geom_boxplot(draw_quantiles = c(0.5), outliers = FALSE) +
      # ylim(0, 25000) +
        scale_fill_manual(values=te.cols, name ='TE content', 
                        labels = c('none', 'is complete', 'is fragment', 
                                   'contains complete', 'contains fragment')
                        ) +
      xlab('TE content') + ylab(paste(meth.type, 'methylation', sep = ' ')) +
      # scale_y_log10() + 
      geom_jitter(width = 0.2, size = 1, alpha = 0.1, stroke = 0) +
      theme_minimal() +
      guides(fill = FALSE) + theme(legend.position = "none") +
      # scale_x_discrete(labels = c('none', 'is complete', 'is fragment', 
      #                              'contains complete', 'contains fragment')) +
      theme(axis.text.x = element_text(angle = 30, hjust = 1))
    
    g
    
    
    pdf(paste(path.figures.meth, 'meth_',meth.type, '_in_te_type_',s.stat,'_',min.len,'_super.pdf', sep = ''), 
        width = 5, height = 4)
    print(g )     # Plot 1 --> in the first page of PDF
    dev.off()
  
  }
  
}
```


# Frequency plots for every category
```{r}


tmp = sv.se[sv.se$te == 'isTEpart',]

unique(sv.se$te )
tmp = tmp[tmp$len >= 100,]

plot(tmp$meth, tmp$freq)


```



## On graph
```{r}

# source(paste(path.pannagram, 'sv/graph_refinement.R', sep = ''))


sv.graph$nodes$gr = sapply(sv.graph$nodes$name, function(s) strsplit(s, '\\|')[[1]][1])

# Add methylation in accessions
names.common = intersect(sv.graph$nodes$gr, names(sv.se.meth.max))
sv.graph$nodes$meth = NA
rownames(sv.graph$nodes) = sv.graph$nodes$gr
sv.graph$nodes[names.common,]$meth = sv.se.meth.max[names.common]
rownames(sv.graph$nodes) = sv.graph$nodes$name

seqs.trait = setNames(sv.graph$nodes$meth, as.character(sv.graph$nodes$name))

sv.graph$nodes.traits$meth = traitsSeqToNode(sv.graph$nodes, 
                                                   seqs.trait = seqs.trait,
                                                   mode = 'max')[sv.graph$nodes.traits$node]


```


### Meth: Separately visualise connected components
```{r}

g.part <- network(sv.graph$edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.names = network.vertex.names(g.part)

# Get components
g.comp <- getGraphComponents(sv.graph$edges)

g.comp.cnt = table(g.comp$membership)
g.comp.cnt = -sort(-g.comp.cnt)
head(g.comp.cnt)

# ------------------------------------
# The biggest component
# ------------------------------------
k = 1
comp.id = as.numeric(names(g.comp.cnt)[k])


comp.names = names(g.comp$membership)[g.comp$membership == comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)


# g.part.sub.big %v% "node.size" = as.numeric(sv.graph$nodes.traits[g.part.sub.big.names,]$cnt)
g.part.sub.big %v% "colors" = as.character(round(sv.graph$nodes.traits[g.part.names,]$meth * 3) )

# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = 1, 
            color = "colors",
            # alpha = 'alpha',
            mode = 'kamadakawai',
            palette = c('0' = '#FDAF7B', '1' = '#BE7B72', '2' = '#824D74', '3' = '#401F71')
            ) + guides(size = F)
p.big.type = p + theme(legend.position = "none")
p.big.type


# ------------------------------------
# Small components
# ------------------------------------

# Construct the graph object
comp.names = names(g.comp$membership)[g.comp$membership != comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)



# g.part.sub.big %v% "node.size" = as.numeric(sv.graph$nodes.traits[g.part.sub.big.names,]$cnt)
g.part.sub.big %v% "colors" = as.character(round(sv.graph$nodes.traits[g.part.names,]$meth * 3) )

# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            node.size = 1, 
            color = "colors",
            # alpha = 'alpha',
            # mode = 'kamadakawai',
            palette = c('0' = '#FDAF7B', '1' = '#BE7B72', '2' = '#824D74', '3' = '#401F71')
            ) + guides(size = F)
p.small.type = p + theme(legend.position = "none")
p.small.type





```

## Meth: no-TE SVs
```{r}




g.part <- network(sv.new$edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.names = network.vertex.names(g.part)
g.part.names = sapply(g.part.names, function(s) strsplit(s, '\\|')[[1]][1])
# 
# # Cut the graph
# tmp.edges = sv.new$edges
# g.part.names = g.part.names[g.part.names %in% names(sv.se.meth.max)]
# g.part.names = names(g.part.names)
# tmp.edges = tmp.edges[(tmp.edges[,1] %in% g.part.names) & (tmp.edges[,2] %in% g.part.names) ,]
# g.part <- network(tmp.edges, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
# g.part.names = network.vertex.names(g.part)
# g.part.names = sapply(g.part.names, function(s) strsplit(s, '\\|')[[1]][1])



g.part %v% "colors" = as.character(round(sv.se.meth.max[g.part.names] * 2) )


set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "grey30", 
            node.size = 1,
            color = "colors",
            palette = c('0' = '#59D5E0', '1' = '#FAA300', '2' = '#F4538A')
            # palette = c('0' = '#FDAF7B', '1' = '#BE7B72', '2' = '#824D74', '3' = '#401F71')
            # mode = "kamadakawai"
            ) + guides(size = F) + coord_fixed(ratio = 1) 
p = p+ theme(legend.key.height = unit(0.5, "cm"))
p


```

### Hmmmm I see the difference
```{r}




for(i.com in cl.np.prot){
  pokaz(i.com)
  names.com.sv = names(sv.graphcomp$membership[sv.graphcomp$membership == i.com])
  names.len = as.numeric(sapply(names.com.sv, function(s) tail(strsplit(s, '\\|')[[1]], 1)))
  print(names.len)
  
  
  names.com.sv = sapply(names.com.sv, function(s) strsplit(s, '\\|')[[1]][1])
  
  print(sv.se.meth.max[names.com.sv])
  
}


sv.pos.beg['SVgr_1_id_119434',colnames(x)]
sv.pos.end['SVgr_1_id_119434',colnames(x)]

sv.pos.end['SVgr_1_id_119434',colnames(x)] - sv.pos.beg['SVgr_1_id_119434',colnames(x)]


x['SVgr_1_id_119434',]

```


# EXPRESSION
```{r}


sv.se.exp.max.all = list()
sv.se.exp.mean.all = list()


x = read.table('/Volumes/Samsung_T5/vienn/00_paper/01_data/05_expression/02_on_sv_v03/counts.SVs.bed',
               row.names = 1, header = 1, check.names = F)

idx.x.tissues <- grep("^[SRFP]\\.", colnames(x), ignore.case = F)
pokaz('Removed:', colnames(x)[-idx.x.tissues])
x = x[,idx.x.tissues]

x.acc.name = sapply(colnames(x), function(s) strsplit(s, '\\.')[[1]][2])
x.tissue = sapply(colnames(x), function(s) strsplit(s, '\\.')[[1]][1])
acc.unique = unique(x.acc.name)

df.expr = list()
for(acc in acc.unique){
  pokaz('Accession', acc)
  idx.acc = x.acc.name == acc
  y = x[,idx.acc]
  colnames(y) = x.tissue[idx.acc]
  
  
  y = y[rowSums(!is.na(y)) != 0,]
  y[is.na(y)] = 0
  
  common.names = intersect(rownames(y), rownames(sv.pos.bin))
  y.bin = sv.pos.bin[common.names,acc]
  y = y[common.names,]
  
  y[is.na(y),] = 0
  
  y = y[y.bin != 0,]
  
  y = as.data.frame(y)
  y$names = rownames(y)
  
  y.long = reshape2::melt(y, id.vars = 'names')
  
  df.expr[[acc]] = y.long

}


```

## Noramlise by length
```{r}
tmp = df.expr
rownames(sv.se) = sv.se$gr
for(i in 1:length(df.expr)){
  df.expr[[i]]$value = df.expr[[i]]$value / sv.se[df.expr[[i]]$names,]$len
}


```



## Expr: violineplot
```{r}

sv.target = sv.se$gr[sv.se$freq.max >= 25]

path.figures.meth = paste(path.figures, 'expression_norm_high/', sep = '')

if (!dir.exists(path.figures.meth)) {
  dir.create(path.figures.meth, recursive = TRUE)
} 

min.len = 100
for(acc in names(df.expr)){
  pokaz('Accession', acc)
  
  # for(s.stat in c('mean', 'max')){
  df = df.expr[[acc]]
  
  # # target
  # df = df[df$names %in% sv.target,]
  
  df$te = sv.se[as.character(df$names),]$te
  df$len = sv.se[df$names,]$len
    
  df$te = factor(df$te, levels = names(te.cols))
  df = df[df$len > min.len,]
    
  g = ggplot(df, 
             aes(x = interaction(variable, te, sep = " - "), 
                 y = value, 
                  # color = te,
                 fill = te)) +
    geom_violin(draw_quantiles = c(0.5)) +
    # ylim(0, 25000) +
      scale_fill_manual(values=te.cols, name ='TE content', 
                      labels = c('none', 'is complete', 'is fragment', 
                                 'contains complete', 'contains fragment')
                      ) +
    xlab('TE content') + ylab(NULL) +
    scale_y_log10() +
    geom_jitter(width = 0.2, size = 1, alpha = 0.5, stroke = 0) +
    theme_minimal() +
    guides(fill = FALSE) + theme(legend.position = "none") +
    # scale_x_discrete(labels = c('none', 
    #                             'is complete',
    #                             'contains complete',
    #                             'contains fragment', 
    #                             'is fragment')) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1))
  
  g
    
    
  pdf(paste(path.figures.meth, 'expr_acc_',acc, '_',min.len,'.pdf', sep = ''), 
      width = 5, height = 4)
  print(g )     # Plot 1 --> in the first page of PDF
  dev.off()


  
}


```

## Expr: common plot
```{r}
sv.target = sv.se$gr[sv.se$freq.max >= 25]

path.figures.heatmap = paste(path.figures, 'expression_norm_heatmap/', sep = '')

if (!dir.exists(path.figures.heatmap)) {
  dir.create(path.figures.heatmap, recursive = TRUE)
} 

mode.in.graph = T

min.len = 1000
result.all = c()
for(acc in names(df.expr)){
  pokaz('Accession', acc)
  
  # for(s.stat in c('mean', 'max')){
  df = df.expr[[acc]]
  
  
  
  # target
  # df = df[df$names %in% sv.target,]
  if(mode.in.graph){
    df = df[df$names %in% sv.names.in.graph,]  
    s.suffix = '_in_graph'
  } else {
    s.suffix = ''
  }
  
  
  df$te = sv.se[as.character(df$names),]$te
  df$len = sv.se[df$names,]$len
    
  df$te = factor(df$te, levels = names(te.cols))
  df = df[df$len > min.len,]
    
  
  result <- df %>%
  group_by(te, variable) %>%
  summarise(mean_value = mean(value), .groups = 'drop')
  
  result$comb = paste(result$te, result$variable, sep = '_')
  result$acc = acc
   
  result.all = rbind(result.all, result) 

}





```


### accessions order
```{r}
admix=list(germany=c("1741","6909"),
            south_sweden=c("6024","6124"),
            north_sweden=c("6069","6244"),
            western_europe=c("6966","10002"),
            central_europe=c("8236","9728"),
            italy_balkan_caucasus=c("9075","9981"),
            spain=c("9537","9888"),
            relict=c("9543","9905"),
            asia=c("9638","10015"),
            admixed=c("9764"),
            africa=c("10024","22003","22004","22007"),
            china=c("22001","22002","220011"),
            madeira=c("22005","22006"))


acc.admix <- c()

# Перебираем исходный список и меняем местами имена и значения
for (region in names(admix)) {
  ids <- admix[[region]]
  for (id in ids) {
    acc.admix[id] <- region
  }
}

acc.admix = sort(acc.admix)


```



### Heatmap

```{r}
result.all <- result.all %>%
  group_by(acc) %>%
  mutate(normalized_value = scales::rescale(mean_value, to = c(0, 1))) %>%
  ungroup()

result.all$acc = factor(result.all$acc, levels = names(acc.admix))

p = ggplot(result.all, aes(x = variable, y = acc, fill = log(normalized_value,base = 10))) +
  geom_tile() +
  facet_grid(cols = vars(te),
             labeller = as_labeller(c('noTE' = 'no TE', 
                                            'isTE' = 'is compl. TE', 
                                            'isTEpart' = 'is TE fragm.', 
                                            'hasTE' = 'contains compl. TE', 
                                            'hasTEpart' = 'contains TE fragm.'))) + 
  # scale_fill_gradient(low = "blue", high = "red") +
  # scale_fill_viridis(option = "C") +
  scale_fill_gradientn(colors = c("#A2CDCD", "#CEE5D0", "#FFE1AF", "#D57E7E"), na.value = '#A2CDCD') +
  labs(title = "Mean Expression Values: normalized to [0,1] and log10-transformed", 
       x = "Tissue", y = "Accessions", fill = 'log10') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1),
        axis.text.y = element_text(size = 6),
        legend.position = "bottom")
p



pdf(paste(path.figures.heatmap, 'expr_heatmap_',min.len,s.suffix,'.pdf', sep = ''),
    width = 7, height = 3.5)
print(p )     # Plot 1 --> in the first page of PDF
dev.off()

```

```{r}
p = ggplot(result.all, aes(x = variable, y = normalized_value,
                           color = log(normalized_value, base = 10))) +
  geom_jitter(width = 0.2) +
  geom_boxplot(aes(group = variable), fill = NA, outliers = F) +
  facet_grid(cols = vars(te),
             labeller = as_labeller(c('noTE' = 'no TE', 
                                      'isTE' = 'is compl. TE', 
                                      'isTEpart' = 'is TE fragm.', 
                                      'hasTE' = 'contains compl. TE', 
                                      'hasTEpart' = 'contains TE fragm.'))) + 
  scale_color_gradientn(colors = c("#A2CDCD", "#CEE5D0", "#FFE1AF", "#D57E7E"), na.value = '#A2CDCD') +
  labs(title = "Mean Expression Values: normalized to [0,1] per accession", 
       x = "Tissue", y = "Normalized Value", color = 'log10') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1),
        legend.position = "bottom")
p

pdf(paste(path.figures.heatmap, 'expr_boxplot_',min.len,s.suffix,'.pdf', sep = ''),
    width = 7, height = 3)
print(p )     # Plot 1 --> in the first page of PDF
dev.off()

```



# EXPRESSION - old
```{r}

path.expr = '/Users/annaigolkina/Library/CloudStorage/OneDrive-Personal/vienn/pacbio/1001Gplus_paper/01_data/05_expression/mapping_bed/'

files = list.files(path.expr, pattern = '\\.bedGraph$')
files


expr.cutoff = 2

accessions= unique(sapply(files, function(s) strsplit(s, '\\.')[[1]][2]))

sv.pos.bin.long = sv.pos.bin[sv.se$len >= 100,]
rownames(sv.se) = sv.se$gr

sv.express = matrix(0, nrow = nrow(sv.pos.bin.long), ncol = length(files), 
                    dimnames = list(rownames(sv.pos.bin.long), files))

sv.express.max = matrix(0, nrow = nrow(sv.pos.bin.long), ncol = length(files), 
                    dimnames = list(rownames(sv.pos.bin.long), files))

# gsub('.bedGraph', '',files)

for(f in files[-(1:18)]){
    
  acc = sapply(f, function(s) strsplit(s, '\\.')[[1]][2])
  pokaz('Accession', acc)
  if(acc == '22001') next
  
  expr.values.all = read.table(paste(path.expr, f, sep = ''))
  

  
  sv.pos.bin.acc = sv.pos.bin.long[, acc, drop = F]
  sv.pos.bin.acc = sv.pos.bin.acc[sv.pos.bin.acc != 0, ,drop = F]
  
  pos.names = rownames(sv.pos.bin.acc)
  pos.beg.acc = sv.pos.beg[pos.names, acc]
  pos.end.acc = sv.pos.end[pos.names, acc]
  
  
  
  for(i.chr in 1:5){
    pokaz('Chr', i.chr)
    expr.values = expr.values.all[expr.values.all$V1 == paste(acc, '_Chr', i.chr, sep = ''),]
    expr.values$len = expr.values$V3 - expr.values$V2
    pos.expr = rep(0,max(expr.values$V3))
    pos.expr[expr.values$V2+1] = expr.values$V4
    pos.expr[expr.values$V3] = -expr.values$V4
    pos.expr = cumsum(pos.expr)
    pos.expr[expr.values$V3] = expr.values$V4
    
    if(round(sum(expr.values$len * expr.values$V4)) != round(sum(pos.expr))) stop('Problem with expression mapping')
    
    
    idx.sv.chr <- grep(paste("SVgr_",i.chr,"_", sep = ''), rownames(sv.pos.bin.acc))
    
    for(i.sv in idx.sv.chr){
      sv.express[pos.names[i.sv], f] = mean(pos.expr[pos.beg.acc[i.sv]:pos.end.acc[i.sv]])
      sv.express.max[pos.names[i.sv], f] = max(pos.expr[pos.beg.acc[i.sv]:pos.end.acc[i.sv]])
    }
    
    
  }  # i.chr
  
  
  
}

saveRDS(sv.express, paste(path.expr, 'sv_expression_mean.rds', sep = ''))
saveRDS(sv.express.max, paste(path.expr, 'sv_expression_max.rds', sep = ''))

plot(rowMax(sv.express), rowMax(sv.express.max))


expression = rowMax(sv.express)
expression = (expression > 1) * 1
expression[is.na(expression)] = 0

```

# Add expr into datafile
```{r}


# Add methylation in accessions
names.common = intersect(sv.graph$nodes$gr, names(expression))
sv.graph$nodes$expr = 0
rownames(sv.graph$nodes) = sv.graph$nodes$gr
sv.graph$nodes[names.common,]$expr = expression[names.common]
rownames(sv.graph$nodes) = sv.graph$nodes$name

seqs.trait = setNames(sv.graph$nodes$expr, as.character(sv.graph$nodes$name))

sv.graph$nodes.traits$expr = traitsSeqToNode(sv.graph$nodes, 
                                                   seqs.trait = seqs.trait,
                                                   mode = 'max')[sv.graph$nodes.traits$node]

```

### EXPRE:Separately visualise connected components
```{r}

# Get components
g.comp <- getGraphComponents(sv.graph$edges)

g.comp.cnt = table(g.comp$membership)
g.comp.cnt = -sort(-g.comp.cnt)
head(g.comp.cnt)

# ------------------------------------
# The biggest component
# ------------------------------------
k = 1
comp.id = as.numeric(names(g.comp.cnt)[k])


comp.names = names(g.comp$membership)[g.comp$membership == comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)


g.part.sub.big %v% "colors" = as.character(sv.graph$nodes.traits[g.part.sub.big.names,]$type)
g.part.sub.big %v% "node.size" = as.numeric(sv.graph$nodes.traits[g.part.sub.big.names,]$expr) + 0.1

g.part.sub.big %v% "alpha" = as.integer(sv.graph$nodes.traits[g.part.sub.big.names,]$meth > 0.3) * 0.8 + 0.2

# g.part.sub.big %v% "colors" = as.character(round(sv.graph$nodes.traits[g.part.sub.big.names,]$meth * 3) )

g.part.sub.big %v% "colors" = as.character(sv.graph$nodes.traits[g.part.sub.big.names,]$expr)


# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            # node.size = "node.size", 
            node.size = 1,
            color = "colors",
            # alpha = 'alpha',
            mode = 'kamadakawai',
            palette = c('0' = '#FDAF7B', '1' = '#401F71')
            # palette = te.cols
            ) + guides(size = F)
p.big.type = p + theme(legend.position = "none")
p.big.type


# ------------------------------------
# Small components
# ------------------------------------

# Construct the graph object
comp.names = names(g.comp$membership)[g.comp$membership != comp.id]
sv.graph.sub = sv.graph$edges[(sv.graph$edges[,1] %in% comp.names) & 
                               (sv.graph$edges[,2] %in% comp.names),]

# Construct the graph object
g.part.sub.big <- network(sv.graph.sub, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
g.part.sub.big.names = network.vertex.names(g.part.sub.big)


g.part.sub.big %v% "colors" = as.character(sv.graph$nodes.traits[g.part.sub.big.names,]$type)
g.part.sub.big %v% "node.size" = as.numeric(sv.graph$nodes.traits[g.part.sub.big.names,]$expr) + 0.1

# g.part.sub.big %v% "alpha" = as.integer(sv.graph$nodes.traits[g.part.names,]$meth > 0.3) * 0.8 + 0.2

g.part.sub.big %v% "colors" = as.character(round(sv.graph$nodes.traits[g.part.sub.big.names,]$meth * 3) )
g.part.sub.big %v% "colors" = as.character(sv.graph$nodes.traits[g.part.sub.big.names,]$expr)

# Visualise
set.seed(20)
p <- ggnet2(g.part.sub.big, label = F, edge.color = "black", 
            # node.size = "node.size", 
            node.size = 1,
            color = "colors",
            # alpha = 'alpha',
            # mode = 'kamadakawai',
            palette = c('0' = '#FDAF7B', '1' = '#401F71')
            # palette = te.cols
            ) + guides(size = F)
p.small.type = p + theme(legend.position = "none")
p.small.type


table(sv.graph$nodes$expr, sv.graph$nodes$type)


```

## Expr: no-TE SVs
```{r}

g.part %v% "colors" = sv.memb[g.part.names, 'prot']
g.part.names.cut = sapply(g.part.names, function(s) strsplit(s, '\\|')[[1]][1])


g.part %v% "colors" = as.character(expression[g.part.names.cut])


set.seed(239)
p <- ggnet2(g.part, label = F, edge.color = "black", 
            node.size = 1,
            color = "colors",
            palette = c('0' = '#FDAF7B', '1' = '#401F71')
            # mode = "kamadakawai"
            ) + guides(size = F) + coord_fixed(ratio = 1) 
p = p+ theme(legend.key.height = unit(0.5, "cm"))
p




```
### Expression and BLAST
```{r}

sv.memb$prot
sv.memb$name
sv.memb$gr = sapply(sv.memb$name, function(s) strsplit(s, '\\|')[[1]][1])
sv.memb$expr = expression[sv.memb$gr]
# sv.memb$expr[is.na(sv.memb$expr)] = 0




library(ggplot2)
library(dplyr)
library(tidyr)

cnt = as.data.frame(table(sv.memb$prot, sv.memb$expr))

ggplot(cnt, aes(x = Var1, y = Freq, fill = Var2)) +
  geom_bar(stat = "identity", position = "fill") +  # Использование position = "fill"
  labs(x = "Row Name", y = "Proportion", fill = "Column Name") +  # Изменение метки оси Y
  theme_minimal()

```


# OLD
```{r}
sunset <- colour("sunset")
discrete_rainbow <- colour("discrete rainbow")

file.te = '/Volumes/Samsung_T5/vienn/work/blast_tes_ann.txt'
sim.cutoff = 0.85
len.cutoff = 100
```


```{r}

b = read.table(file.te, stringsAsFactors = F)
b = b[b$V1 != b$V8,]
b$len1 = as.numeric(sapply(b$V1, function(s) strsplit(s, '\\|')[[1]][7]))
b$len2 = as.numeric(sapply(b$V8, function(s) strsplit(s, '\\|')[[1]][7]))
b = b[b$len1 >= len.cutoff,]
b = b[b$len2 >= len.cutoff,]
b$comb = paste(b$V1, b$V8, sep = '^')

# Order positions in base
idx = b$V4 > b$V5
tmp = b[idx, 'V4']
b[idx, 'V4'] = b[idx, 'V5']
b[idx, 'V5'] = tmp

# --------------------------------------------------
# Get separately those, who has a unique coverage
comb.tbl = table(b$comb)
idx.uni = b$comb %in% names(comb.tbl)[comb.tbl == 1]
b.uni = b[idx.uni,]
b = b[!idx.uni,]

# This variable will be used later
b.uni$p1 = (b.uni$V3 - b.uni$V2 + 1) / b.uni$len1
b.uni$p2 = (b.uni$V5 - b.uni$V4 + 1) / b.uni$len2
b.uni = b.uni[(b.uni$p1 >= sim.cutoff) | (b.uni$p2 >= sim.cutoff),]

b.relations = data.frame(sub.te = b.uni$V1[b.uni$p1 >= sim.cutoff],
                         te = b.uni$V8[b.uni$p1 >= sim.cutoff], stringsAsFactors = F)
b.relations = rbind(b.relations,
                    data.frame(sub.te = b.uni$V8[b.uni$p2 >= sim.cutoff],
                               te = b.uni$V1[b.uni$p2 >= sim.cutoff], stringsAsFactors = F))
b.relations = unique(b.relations)

# --------------------------------------------------
# Min-max of the coverage to remove those, who are NOT in each other completely
b.cov = tapply(b$V2, b$comb, min)
b.cov = data.frame(comb = names(b.cov), V2 = b.cov)
b.cov$V3 = tapply(b$V3, b$comb, max)
b.cov$V4 = tapply(b$V4, b$comb, min)
b.cov$V5 = tapply(b$V5, b$comb, max)
b.cov$len1 = tapply(b$len1, b$comb, unique)
b.cov$len2 = tapply(b$len2, b$comb, unique)
b.cov$p1 = (b.cov$V3 - b.cov$V2 + 1) / b.cov$len1
b.cov$p2 = (b.cov$V5 - b.cov$V4 + 1) / b.cov$len2

comb.uncov = b.cov$comb[(b.cov$p1 < sim.cutoff) & (b.cov$p2 < sim.cutoff)]

b = b[!(b$comb %in% comb.uncov),]

# --------------------------------------------------
# Calculate the coverage directly for the first
b = b[order(b$V3),]
b = b[order(b$V2),]
b = b[order(b$comb),]

# Remove nested
idx = which((b$V3[-nrow(b)] > b$V3[-1]) & (b$comb[-nrow(b)] == b$comb[-1])) + 1
b1 = b[-idx,]

# Compute gaps
b1$gap = c(b1$V2[-1] - b1$V3[-nrow(b1)] - 1, 0)
b1$gap[b1$gap < 0] = 0
idx.diff.comb = which(b1$comb[-1] != b1$comb[-nrow(b1)])
b1$gap[idx.diff.comb] = 0

b.cov = tapply(b1$V2, b1$comb, min)
b.cov = data.frame(comb = names(b.cov), V2 = b.cov)
b.cov$V3 = tapply(b1$V3, b1$comb, max)
b.cov$len1 = tapply(b1$len1, b1$comb, unique)
b.cov$gap = tapply(b1$gap, b1$comb, sum)
b.cov$len1 = b.cov$len1 
b.cov$p1 = (b.cov$V3 - b.cov$V2 + 1 - b.cov$gap) / b.cov$len1
b.cov$V1 = tapply(b1$V1, b1$comb, unique)
b.cov$V8 = tapply(b1$V8, b1$comb, unique)

b.cov = b.cov[b.cov$p1 >= sim.cutoff,]


b.relations = rbind(b.relations,
                    data.frame(sub.te = b.cov$V1,
                               te = b.cov$V8, stringsAsFactors = F))


# --------------------------------------------------
# Calculate the coverage directly for the second
b = b[order(b$V5),]
b = b[order(b$V4),]
b = b[order(b$comb),]

# Remove nested
idx = which((b$V5[-nrow(b)] > b$V5[-1]) & (b$comb[-nrow(b)] == b$comb[-1])) + 1
b1 = b[-idx,]

# Compute gaps
b1$gap = c(b1$V4[-1] - b1$V5[-nrow(b1)] - 1, 0)
b1$gap[b1$gap < 0] = 0
idx.diff.comb = which(b1$comb[-1] != b1$comb[-nrow(b1)])
b1$gap[idx.diff.comb] = 0

b.cov = tapply(b1$V4, b1$comb, min)
b.cov = data.frame(comb = names(b.cov), V4 = b.cov)
b.cov$V5 = tapply(b1$V5, b1$comb, max)
b.cov$len2 = tapply(b1$len2, b1$comb, unique)
b.cov$gap = tapply(b1$gap, b1$comb, sum)
b.cov$len2 = b.cov$len2 
b.cov$p1 = (b.cov$V5 - b.cov$V4 + 1 - b.cov$gap) / b.cov$len2
b.cov$V1 = tapply(b1$V1, b1$comb, unique)
b.cov$V8 = tapply(b1$V8, b1$comb, unique)

b.cov = b.cov[b.cov$p1 >= sim.cutoff,]


b.relations = rbind(b.relations,
                    data.frame(sub.te = b.cov$V8,
                               te = b.cov$V1, stringsAsFactors = F))

  
b.relations = unique(b.relations)


b.relations

```


# Define clusters
```{r}
b.nodes = rbind(b.relations,
                    data.frame(sub.te = b.relations$te,
                               te = b.relations$sub.te))

b.nodes$comb = paste(b.nodes$sub.te, b.nodes$te, sep = '^')

comb.tbl = table(b.nodes$comb)
comb.back.and.foth = names(comb.tbl)[comb.tbl >= 2]
b.nodes = b.nodes[b.nodes$comb %in% comb.back.and.foth,]
b.nodes = unique(b.nodes[, c('sub.te', 'te')])


te.nodes <- igraph::make_graph(t(b.nodes), directed = T)
te.nodes <- igraph::simplify(te.nodes)
te.nodes.comp <- igraph::components(te.nodes)

nodes = paste('N', te.nodes.comp$membership, sep = '')
names(nodes) = names(te.nodes.comp$membership)
```

## Identify family for each node
```{r}

nodes.family = sapply(names(nodes), function(s) strsplit(s, '\\|')[[1]][6])

nodes.family.max = tapply(nodes.family, nodes, function(s){
  tbl = table(s)
  f = names(tbl)[tbl == max(tbl)]
  if(length(f) == 1){
    return(f)
  } else {
    return('Mix')
  }
})

nodes.family.max[nodes.family.max %in% c('DNA/Pogo', 'DNA/Tc1', 'DNA/Harbinger', 'DNA/En-Spm',
                     'DNA/HAT', 'DNA', 'DNA/Mariner')] = 'DNA'
nodes.family.max[nodes.family.max %in% c('RathE1_cons', 'RathE2_cons')] = 'DNA'
nodes.family.max[nodes.family.max %in% c('LINE/L1', 'LINE?')] = 'LINE'
nodes.family.max[nodes.family.max %in% c('Unassigned')] = 'Mix'
nodes.family.unique = unique(nodes.family.max)



```


## Graph without singletons
```{r}

b.graph.init = b.relations[(b.relations$sub.te %in% names(nodes)) & (b.relations$te %in% names(nodes)),]
b.graph = b.graph.init
b.graph = cbind(nodes[as.character(b.graph$sub.te)], nodes[as.character(b.graph$te)])
b.graph = unique(b.graph)


b.graph = b.graph[b.graph[,1] != b.graph[,2],]

# reduce indirect arrows
idx.remove = c()
for(i.edge in 1:nrow(b.graph)){
  if(i.edge %% 1000 == 0) print(i.edge)
  tmp.to = b.graph[b.graph[,1] == b.graph[i.edge,1],2]
  tmp.from = b.graph[b.graph[,2] == b.graph[i.edge,2],1]
  if(length(intersect(tmp.to, tmp.from)) > 0) idx.remove = c(idx.remove, i.edge)
}
idx.remove = unique(idx.remove)
b.graph = b.graph[-idx.remove,]


# te.graph <- igraph::make_graph(t(b.graph), directed = T)
# te.graph <- igraph::simplify(te.graph)
# te.graph.comp <- igraph::components(te.graph)


nodes.family.max.graph = nodes.family.max[names(nodes.family.max) %in% unique(c(b.graph[,1], b.graph[,2]))]

graph.cols = sunset(length(unique(nodes.family.max.graph)))

graph.cols = discrete_rainbow(length(unique(nodes.family.max.graph)))
names(graph.cols) = unique(nodes.family.max.graph)
g.part <- network(b.graph, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
p <- ggnet2(g.part, label = FALSE, edge.color = "black", node.size = 1, 
            color = nodes.family.max.graph, palette = graph.cols,
            mode = "kamadakawai")# + guides(size = FALSE)
p

```
## Graph WITH singletons
```{r}


names.core = names(nodes.family.max.graph)

b.graph.init = b.relations
for(i in 1:2){
  b.graph.init[b.graph.init[,i] %in% names(nodes), i] = nodes[b.graph.init[b.graph.init[,i] %in% names(nodes), i]]
}

b.graph = unique(b.graph.init)
b.graph = b.graph[b.graph[,1] != b.graph[,2],]
b.graph = unique(b.graph)
# Verteces from the previous graph
b.graph = b.graph[(b.graph[,1] %in% names.core) | (b.graph[,2] %in% names.core),]


# reduce indirect arrows
idx.remove = c()
for(i.edge in 1:nrow(b.graph)){
  if(i.edge %% 1000 == 0) print(i.edge)
  tmp.to = b.graph[b.graph[,1] == b.graph[i.edge,1],2]
  tmp.from = b.graph[b.graph[,2] == b.graph[i.edge,2],1]
  if(length(intersect(tmp.to, tmp.from)) > 0) idx.remove = c(idx.remove, i.edge)
}
idx.remove = unique(idx.remove)
b.graph = b.graph[-idx.remove,]

te.graph <- igraph::make_graph(t(b.graph), directed = T)
d <- igraph::distances(te.graph)
# te.graph <- igraph::simplify(te.graph)
# te.graph.comp <- igraph::components(te.graph)

names.new = unique(setdiff(c(b.graph[,1], b.graph[,2]), names(nodes.family.max)))
# names.new.val = paste('G',1:length(names.new), sep = '')
# names(names.new.val) = names.new
# names.new.val = 

names.new.family = sapply(names.new, function(s) strsplit(s, '\\|')[[1]][6])
names.new.family[names.new.family %in% c('DNA/Pogo', 'DNA/Tc1', 'DNA/Harbinger', 'DNA/En-Spm',
                     'DNA/HAT', 'DNA', 'DNA/Mariner')] = 'DNA'
names.new.family[names.new.family %in% c('RathE1_cons', 'RathE2_cons')] = 'DNA'
names.new.family[names.new.family %in% c('LINE/L1', 'LINE?')] = 'LINE'
names.new.family[names.new.family %in% c('Unassigned')] = 'Mix'


nodes.family.max.add = c(nodes.family.max, names.new.family)
nodes.family.max.add = nodes.family.max.add[unique(c(b.graph[,1], b.graph[,2]))]

graph.cols = discrete_rainbow(length(unique(nodes.family.max.add)))
graph.cols = sample(graph.cols)
names(graph.cols) = unique(nodes.family.max.add)

g.part <- network(b.graph, matrix.type = "edgelist", ignore.eval = FALSE, directed = TRUE)
p <- ggnet2(g.part, label = FALSE, edge.color = "black", node.size = 0.5, 
            color = nodes.family.max.add,
            palette = graph.cols, mode = "kamadakawai")
p
```

# TSNE
```{r}


library(Rtsne)




d <- igraph::distances(te.graph)
d.max = max(d[!is.infinite(d)])

d[is.infinite(d)] = d.max * 1.3

tSNE <- Rtsne(d, is_distance = TRUE, dims = 2)

plot(tSNE$Y[,1], tSNE$Y[,2])

```



