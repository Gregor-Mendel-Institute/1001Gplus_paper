scale_x_continuous(expand = c(0.1, 0.1)) +
scale_y_continuous(expand = c(0.1, 0.1)) +
theme(legend.key.size = unit(0.5, "cm"))  +
guides(color = guide_legend(ncol = 2 )) +
theme(legend.position = "bottom")
set.seed(20)
p.fam <- ggnet2(g.sub, label = sv.graph$nodes.traits[g.sub.names,]$cnt, edge.color = "black",
node.size = sv.graph$nodes.traits[g.sub.names,]$cnt,
label.size = 2,
label.color = 'white',
color =  sv.graph$nodes.traits[g.sub.names,]$fam,
mode = 'kamadakawai',
arrow.gap = 0.06, arrow.size = 3,
palette = fam.palette) +
guides(size = F) +
theme_void() +
scale_x_continuous(expand = c(0.1, 0.1)) +
scale_y_continuous(expand = c(0.1, 0.1)) +
# theme_minimal() + ylab(NULL) + xlab('Number: node size') +
theme(legend.key.size = unit(0.5, "cm"))  +
guides(color = guide_legend(ncol = 2 )) +
theme(legend.position = "bottom")
# p.fam
set.seed(20)
p.freq <- ggnet2(g.sub,
label = sv.graph$nodes.traits[g.sub.names,]$freq,
label.color = 'white',
label.size = 2,
edge.color = "black",
# node.size = sv.graph$nodes.traits[g.sub.names,]$cnt,
node.size = 6,
color =  indel.new.names[sv.graph$nodes.traits[g.sub.names,]$indel],
mode = 'kamadakawai',
arrow.gap = 0.07, arrow.size = 3,
palette = indel.pallete) +
guides(size = F) +
theme_void() +
scale_x_continuous(expand = c(0.1, 0.1)) +
scale_y_continuous(expand = c(0.1, 0.1)) +
# theme_minimal() + ylab(NULL) + xlab('Number: freq of presence') +
theme(legend.key.size = unit(0.5, "cm"))  +
guides(color = guide_legend(ncol = 2 )) +
theme(legend.position = "bottom")
pp = invisible(ggarrange(p.te + annotate("text", x = -Inf, y = Inf,
label = i.target, hjust = 0, vjust = 1),
p.fam ,
p.freq,
nrow=1))
# pp
# TODO: third plot - frequency plot (three of colors: insertion, deletion, indel)
pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'.pdf', sep = ''),
width = 6, height = 3)
print(pp)     # Plot 1 --> in the first page of PDF
dev.off()
}
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[1:20]){
for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
i.target
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[1:20]){
for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
length(seqs.target.msa)
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[1:20]){
for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
if(length(seqs.target) > 50){
message(i.target)
next
}
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
length(seqs.target)
i.target
comp.target
i.target = 3
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
length(seqs.target)
p.msa + annotate("text", x = -Inf, y = Inf,
label = i.target, hjust = 0, vjust = 1)
p.msa + annotate("text", x = -Inf, y = -Inf,
label = i.target, hjust = 0, vjust = 0)
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[1:20]){
for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
if(length(seqs.target) > 50){
message(i.target)
next
}
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa = p.msa + annotate("text", x = -Inf, y = -Inf,
label = i.target, hjust = 0, vjust = 0)
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[1:20]){
for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
if(length(seqs.target) > 50){
message(i.target)
next
}
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa = p.msa + annotate("text", x = -Inf, y = Inf,
label = i.target, hjust = 0, vjust = 1)
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
for(i.target in comp.target[20]){
# for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
if(length(seqs.target) > 50){
message(i.target)
next
}
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa = p.msa + annotate("text", x = -Inf, y = Inf,
label = i.target, hjust = 0, vjust = 1)
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
p.msa
path.mafft = paste(path.work, 'mafft/', sep = '')
if (!dir.exists(path.mafft)) {
dir.create(path.mafft)
}
# for(i.target in comp.target[20]){
for(i.target in 20){
# for(i.target in comp.target){
comp.names = names(g.comp$membership)[g.comp$membership == i.target]
sv.name.target = sv.graph$nodes$name[sv.graph$nodes$node %in% comp.names]
seqs.target = sv.seqs[sv.name.target]
seqs.target.len = as.numeric(sapply(names(seqs.target), function(s) strsplit(s, '\\|')[[1]][2]))
seqs.target = seqs.target[order(-seqs.target.len)]
sv.name.target = names(seqs.target)
if(length(seqs.target) > 50){
message(i.target)
next
}
# Find orientations of sequences
bl.target = bl.res[(bl.res$V1 %in% sv.name.target) & (bl.res$V8 %in% sv.name.target),]
orientation.target = rep('.', length(seqs.target))
names(orientation.target) = sv.name.target
orientation.target[1] = '+'
# TODO: define the first orientation by the longest ORF
dir.seq = c('-', '+')
for(i in 1:(length(orientation.target) - 1)){
bl.tmp = bl.target[bl.target$V1 == sv.name.target[i],]
bl.tmp = bl.tmp[order(-bl.tmp$V7),]
bl.tmp = bl.tmp[!duplicated(bl.tmp$V8),]
bl.tmp$dir = bl.tmp$V5 > bl.tmp$V4
bl.tmp = bl.tmp[orientation.target[bl.tmp$V8] == '.',]
if(nrow(bl.tmp) == 0) next
if(orientation.target[i] == '+'){
orientation.target[bl.tmp$V8] = dir.seq[1 + (bl.tmp$dir) * 1]
}
if(orientation.target[i] == '-'){
orientation.target[bl.tmp$V8] = dir.seq[2 - (bl.tmp$dir) * 1]
}
if(sum(orientation.target == '.') == 0) break
}
#
for(i in which(orientation.target == '-')){
seqs.target[[i]] = rev(seqinr::comp(seqs.target[[i]]))
}
seqs.target.msa = unlist(lapply(seqs.target, function(s) paste0(s, collapse = '')))
seqs.target.msa <- DNAStringSet(seqs.target.msa)
# alignment <- msa(seqs.target.msa)
# Run the alignment
tmp.fasta = paste(path.mafft, 'tmp_',i.target,'.fasta', sep = '')
aln.fasta = paste(path.mafft, 'aln_',i.target,'.fasta', sep = '')
writeXStringSet(seqs.target.msa, filepath = tmp.fasta)
system(paste('mafft --op 5 --quiet --maxiterate 100 ', tmp.fasta, '>', aln.fasta,  sep = ' '))
alignment = readDNAStringSet(aln.fasta)
seqs.mx = as.matrix(alignment)
p.msa = msaplot(seqs.mx)
p.msa = p.msa + annotate("text", x = -Inf, y = Inf,
label = i.target, hjust = 0, vjust = 1)
rownames(sv.se) = sv.se$gr
f.sv = sv.se[sub("\\|.*$", "", names(alignment)),]$freq.max
# pdf(paste(path.components, 'graph_mob_component_', sprintf("%03d", comp.target),'_msa.pdf', sep = ''),
#     width = 6, height = 4)
png(paste(path.components, 'graph_mob_component_', sprintf("%03d", i.target),'_msa.png', sep = ''),
width = 6, height = 4, units = "in", res = 300)
print(p.msa)     # Plot 1 --> in the first page of PDF
dev.off()
}
p.msa
